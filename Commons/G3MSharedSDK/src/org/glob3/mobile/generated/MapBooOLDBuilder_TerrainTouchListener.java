package org.glob3.mobile.generated; 
public class MapBooOLDBuilder_TerrainTouchListener implements TerrainTouchListener
{
  private MapBooOLDBuilder _mapBooBuilder;

  public MapBooOLDBuilder_TerrainTouchListener(MapBooOLDBuilder mapBooBuilder)
  {
     _mapBooBuilder = mapBooBuilder;
  }

  public void dispose()
  {

  }

  public final boolean onTerrainTouch(G3MEventContext ec, Vector2F pixel, Camera camera, Geodetic3D position, Tile tile)
  {
    return _mapBooBuilder.onTerrainTouch(ec, pixel, camera, position, tile);
  }
}
<<<<<<< HEAD bool MapBooBuilder::onTerrainTouch(const G3MEventContext* ec, ======= bool MapBooOLDBuilder::onTerrainTouch(const G3MEventContext* ec, >>>>>>> 882166c33bdf9946c54ea507ad5e1c47fb3e83e0 const Vector2F& pixel, const Camera* camera, const Geodetic3D& position, const Tile* tile) { if (_applicationListener != NULL) { _applicationListener->onTerrainTouch(this, ec, pixel, camera, position, tile); } return true; } PlanetRenderer* MapBooOLDBuilder::createPlanetRenderer() { const bool skirted = true; TileTessellator* tessellator = new PlanetTileTessellator(skirted, Sector::fullSphere()); ElevationDataProvider* elevationDataProvider = NULL; const float verticalExaggeration = 1; TileTexturizer* texturizer = new DefaultTileTexturizer(new DownloaderImageBuilder(URL("http://www.mapboo.com/web/img/tileNotFound.jpg"))); const bool renderDebug = false; const bool forceFirstLevelTilesRenderOnStart = true; const bool incrementalTileQuality = false; const Quality quality = QUALITY_LOW; const TilesRenderParameters* parameters = new TilesRenderParameters(renderDebug, forceFirstLevelTilesRenderOnStart, incrementalTileQuality, quality); const bool showStatistics = false; long long tileDownloadPriority = DownloadPriority::HIGHER; const Sector renderedSector = Sector::fullSphere(); const bool renderTileMeshes = true; const bool logTilesPetitions = false; ChangedRendererInfoListener* changedRendererInfoListener = NULL; TouchEventType touchEventTypeOfTerrainTouchListener = DownUp; PlanetRenderer* result = new PlanetRenderer(tessellator, elevationDataProvider, true, verticalExaggeration, texturizer, _layerSet, parameters, showStatistics, tileDownloadPriority, renderedSector, renderTileMeshes, logTilesPetitions, changedRendererInfoListener, touchEventTypeOfTerrainTouchListener, getTileLODTester(), getTileVisibilityTester()); if (_enableNotifications) { result->addTerrainTouchListener(new MapBooOLDBuilder_TerrainTouchListener(this)); } return result; } const Planet* MapBooOLDBuilder::createPlanet() { return SphericalPlanet::createEarth(); } std::vector<ICameraConstrainer*>* MapBooOLDBuilder::createCameraConstraints(const Planet* planet, PlanetRenderer* planetRenderer) { std::vector<ICameraConstrainer*>* cameraConstraints = new std::vector<ICameraConstrainer*>; const Geodetic3D initialCameraPosition = planet->getDefaultCameraPosition(Sector::fullSphere()); cameraConstraints->push_back( new RenderedSectorCameraConstrainer(planetRenderer, initialCameraPosition._height * 1.2) ); return cameraConstraints; } CameraRenderer* MapBooOLDBuilder::createCameraRenderer() { CameraRenderer* cameraRenderer = new CameraRenderer(); const bool useInertia = true; cameraRenderer->addHandler(new CameraSingleDragHandler(useInertia)); cameraRenderer->addHandler(new CameraDoubleDragHandler()); cameraRenderer->addHandler(new CameraRotationHandler()); return cameraRenderer; } ProtoRenderer* MapBooOLDBuilder::createBusyRenderer() { return new BusyMeshRenderer(Color::newFromRGBA(0, 0, 0, 1)); } class Mapboo_ErrorMessagesCustomizer : public ErrorMessagesCustomizer { private: MapBooOLDBuilder* _mbBuilder; public: Mapboo_ErrorMessagesCustomizer(MapBooOLDBuilder* mbBuilder) { _mbBuilder = mbBuilder; } ~Mapboo_ErrorMessagesCustomizer() {} std::vector<std::string> customize(const std::vector<std::string>& errors) { std::vector<std::string> customizedErrorMessages; const IStringUtils* stringUtils = IStringUtils::instance(); const size_t errorsSize = errors.size(); const std::string appNotFound = "Invalid request: Application #" + _mbBuilder->getApplicationId() + " not found"; for (size_t i = 0; i < errorsSize; i++) { std::string error = errors.at(i); if (stringUtils->beginsWith(error, appNotFound)) { customizedErrorMessages.push_back("Oops, application not found!"); break; } customizedErrorMessages.push_back(error); } return customizedErrorMessages; } }; ErrorRenderer* MapBooOLDBuilder::createErrorRenderer() { return new HUDErrorRenderer(new Mapboo_ErrorMessagesCustomizer(this)); } MapQuestLayer* MapBooOLDBuilder::parseMapQuestLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string imagery = jsonLayer->getAsString("imagery", "<imagery not present>"); if (imagery.compare("OpenAerial") == 0) { return MapQuestLayer::newOpenAerial(timeToCache); } return MapQuestLayer::newOSM(timeToCache); } BingMapsLayer* MapBooOLDBuilder::parseBingMapsLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string key = jsonLayer->getAsString("key", ""); const std::string imagerySet = jsonLayer->getAsString("imagerySet", "Aerial"); return new BingMapsLayer(imagerySet, key, timeToCache, true, 2, 25, 1, NULL, new std::vector<const Info*>()); } CartoDBLayer* MapBooOLDBuilder::parseCartoDBLayer(const JSONObject* jsonLayer, const bool transparent, const TimeInterval& timeToCache) const { const std::string userName = jsonLayer->getAsString("userName", ""); const std::string table = jsonLayer->getAsString("table", ""); return new CartoDBLayer(userName, table, timeToCache, true, 1, transparent, NULL, new std::vector<const Info*>()); } MapBoxLayer* MapBooOLDBuilder::parseMapBoxLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string mapKey = jsonLayer->getAsString("mapKey", ""); return new MapBoxLayer(mapKey, timeToCache, true, 1, 19, 1, NULL, new std::vector<const Info*>()); } WMSLayer* MapBooOLDBuilder::parseWMSLayer(const JSONObject* jsonLayer, const bool transparent) const { const std::string mapLayer = jsonLayer->getAsString("layerName", ""); const URL mapServerURL = URL(jsonLayer->getAsString("server", ""), false); const std::string versionStr = jsonLayer->getAsString("version", ""); WMSServerVersion mapServerVersion = WMS_1_1_0; if (versionStr.compare("WMS_1_3_0") == 0) { mapServerVersion = WMS_1_3_0; } const std::string queryLayer = jsonLayer->getAsString("queryLayer", ""); const std::string style = jsonLayer->getAsString("style", ""); const URL queryServerURL = URL("", false); const WMSServerVersion queryServerVersion = mapServerVersion; const Sector sector = parseSector(jsonLayer, "validSector"); std::string imageFormat = jsonLayer->getAsString("imageFormat", "image/png"); const std::string srs = jsonLayer->getAsString("projection", "EPSG:4326"); LayerTilesRenderParameters* layerTilesRenderParameters = NULL; if (srs.compare("EPSG:4326") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters::createDefaultWGS84(0, 17); } else if (srs.compare("EPSG:3857") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters::createDefaultMercator(0, 17); } const double expiration = jsonLayer->getAsNumber("expiration", 0); const long long milliseconds = IMathUtils::instance()->round(expiration); const TimeInterval timeToCache = TimeInterval::fromMilliseconds(milliseconds); const bool readExpired = jsonLayer->getAsBoolean("acceptExpiration", false); return new WMSLayer(mapLayer, mapServerURL, mapServerVersion, queryLayer, queryServerURL, queryServerVersion, sector, imageFormat, srs, style, transparent, NULL, timeToCache, readExpired, layerTilesRenderParameters); } URLTemplateLayer* MapBooOLDBuilder::parseURLTemplateLayer(const JSONObject* jsonLayer, const bool transparent) const { const std::string urlTemplate = jsonLayer->getAsString("url", ""); const int firstLevel = (int) jsonLayer->getAsNumber("firstLevel", 1); const int maxLevel = (int) jsonLayer->getAsNumber("maxLevel", 19); const std::string projection = jsonLayer->getAsString("projection", "EPSG:3857"); const bool mercator = (projection == "EPSG:3857"); const Sector sector = parseSector(jsonLayer, "validSector"); URLTemplateLayer* result; if (mercator) { result = URLTemplateLayer::newMercator(urlTemplate, sector, transparent, firstLevel, maxLevel, TimeInterval::fromDays(30)); } else { result = new URLTemplateLayer(urlTemplate, sector, transparent, TimeInterval::fromDays(30), true, new LevelTileCondition(firstLevel, maxLevel), LayerTilesRenderParameters::createDefaultWGS84(sector, 1, maxLevel)); } return result; } Layer* MapBooOLDBuilder::parseLayer(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == NULL) { return NULL; } if (jsonBaseObjectLayer->asNull() != NULL) { return NULL; } const TimeInterval defaultTimeToCache = TimeInterval::fromDays(30); const JSONObject* jsonLayer = jsonBaseObjectLayer->asObject(); if (jsonLayer == NULL) { ILogger::instance()->logError("Layer is not a json object"); return NULL; } const bool transparent = jsonLayer->getAsBoolean("transparent", false); const std::string layerType = jsonLayer->getAsString("layer", "<layer not present>"); Layer* layer; if (layerType.compare("OSM") == 0) { layer = new OSMLayer(defaultTimeToCache, true, 2, 1, NULL, new std::vector<const Info*>()); } else if (layerType.compare("MapQuest") == 0) { layer = parseMapQuestLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("BingMaps") == 0) { layer = parseBingMapsLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("CartoDB") == 0) { layer = parseCartoDBLayer(jsonLayer, transparent, defaultTimeToCache); } else if (layerType.compare("MapBox") == 0) { layer = parseMapBoxLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("WMS") == 0) { layer = parseWMSLayer(jsonLayer, transparent); } else if (layerType.compare("URLTemplate") == 0) { layer = parseURLTemplateLayer(jsonLayer, transparent); } else { ILogger::instance()->logError("Unsupported layer type \"%s\"", layerType.c_str()); ILogger::instance()->logError("%s", jsonBaseObjectLayer->description().c_str()); return NULL; } const std::string layerAttribution = jsonLayer->getAsString("attribution", ""); if (layerAttribution.compare("") != 0) { layer->addInfo(new Info(layerAttribution)); } return layer; } Color MapBooOLDBuilder::parseColor(const JSONString* jsonColor) const { if (jsonColor == NULL) { return Color::black(); } const Color* color = Color::parse(jsonColor->value()); if (color == NULL) { ILogger::instance()->logError("Invalid format in attribute 'color' (%s)", jsonColor->value().c_str()); return Color::black(); } Color result(*color); delete color; return result; } MapBooOLD_MultiImage_Level* MapBooOLDBuilder::parseMultiImageLevel(const JSONObject* jsonObject) const { const JSONString* jsURL = jsonObject->getAsString("url"); if (jsURL == NULL) { return NULL; } const JSONNumber* jsWidth = jsonObject->getAsNumber("width"); if (jsWidth == NULL) { return NULL; } const JSONNumber* jsHeight = jsonObject->getAsNumber("height"); if (jsHeight == NULL) { return NULL; } return new MapBooOLD_MultiImage_Level(URL(_serverURL, "/images/" + jsURL->value()), (int) jsWidth->value(), (int) jsHeight->value()); } MapBooOLD_MultiImage* MapBooOLDBuilder::parseMultiImage(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } Color averageColor = parseColor( jsonObject->getAsString("averageColor") ); std::vector<MapBooOLD_MultiImage_Level*> levels; const JSONArray* jsLevels = jsonObject->getAsArray("levels"); if (jsLevels != NULL) { const size_t levelsCount = jsLevels->size(); for (size_t i = 0; i < levelsCount; i++) { MapBooOLD_MultiImage_Level* level = parseMultiImageLevel( jsLevels->getAsObject(i) ); if (level != NULL) { levels.push_back(level); } } } return new MapBooOLD_MultiImage(averageColor, levels); } const MapBooOLD_CameraPosition* MapBooOLDBuilder::parseCameraPosition(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } const double latitudeInDegress = jsonObject->getAsNumber("latitude", 0); const double longitudeInDegress = jsonObject->getAsNumber("longitude", 0); const double height = jsonObject->getAsNumber("height", 0); const double headingInDegrees = jsonObject->getAsNumber("heading", 0); const double pitchInDegrees = jsonObject->getAsNumber("pitch", 0); const bool animated = jsonObject->getAsBoolean("animated", true); return new MapBooOLD_CameraPosition(Geodetic3D::fromDegrees(latitudeInDegress, longitudeInDegress, height), Angle::fromDegrees(headingInDegrees), Angle::fromDegrees(pitchInDegrees), animated); } Sector* MapBooOLDBuilder::parseSector(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == NULL) { return NULL; } if (jsonBaseObjectLayer->asNull() != NULL) { return NULL; } const JSONObject* jsonObject = jsonBaseObjectLayer->asObject(); if (jsonObject == NULL) { return NULL; } const double lowerLat = jsonObject->getAsNumber("lowerLat", -90.0); const double lowerLon = jsonObject->getAsNumber("lowerLon", -180.0); const double upperLat = jsonObject->getAsNumber("upperLat", 90.0); const double upperLon = jsonObject->getAsNumber("upperLon", 180.0); return new Sector(Geodetic2D::fromDegrees(lowerLat, lowerLon), Geodetic2D::fromDegrees(upperLat, upperLon)); } const Sector MapBooOLDBuilder::parseSector(const JSONObject* jsonObject, const std::string& paramName) const { const JSONObject* sector = jsonObject->getAsObject(paramName); if (sector == NULL) { return Sector::fullSphere(); } if (sector->asNull() != NULL) { return Sector::fullSphere(); } const double lowerLat = sector->getAsNumber("lowerLat", -90.0); const double lowerLon = sector->getAsNumber("lowerLon", -180.0); const double upperLat = sector->getAsNumber("upperLat", 90.0); const double upperLon = sector->getAsNumber("upperLon", 180.0); return Sector(Geodetic2D::fromDegrees(lowerLat, lowerLon), Geodetic2D::fromDegrees(upperLat, upperLon)); } MapBooOLD_Scene* MapBooOLDBuilder::parseScene(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } const bool hasWarnings = jsonObject->getAsBoolean("hasWarnings", false); const bool queryable = jsonObject->getAsBoolean("queryable", false); return new MapBooOLD_Scene(jsonObject->getAsString("id", ""), jsonObject->getAsString("name", ""), jsonObject->getAsString("description", ""), parseMultiImage( jsonObject->getAsObject("screenshot") ), parseColor( jsonObject->getAsString("backgroundColor") ), parseCameraPosition( jsonObject->getAsObject("cameraPosition") ), parseSector( jsonObject->get("sector") ), parseLayer( jsonObject->get("baseLayer") ), parseLayer( jsonObject->get("overlayLayer") ), queryable, hasWarnings); } const URL* MapBooOLDBuilder::parseURL(const JSONString* jsonString) const { if (jsonString == NULL) { return NULL; } return new URL(jsonString->value()); } MapBooOLD_Notification* MapBooOLDBuilder::parseNotification(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } return new MapBooOLD_Notification(Geodetic2D::fromDegrees(jsonObject->getAsNumber("latitude", 0), jsonObject->getAsNumber("longitude", 0)), parseCameraPosition( jsonObject->getAsObject("cameraPosition") ), jsonObject->getAsString("message", ""), parseURL( jsonObject->getAsString("iconURL") ) ); } std::vector<MapBooOLD_Notification*>* MapBooOLDBuilder::parseNotifications(const JSONArray* jsonArray) const { std::vector<MapBooOLD_Notification*>* result = new std::vector<MapBooOLD_Notification*>(); if (jsonArray != NULL) { const size_t size = jsonArray->size(); for (size_t i = 0; i < size; i++) { MapBooOLD_Notification* notification = parseNotification( jsonArray->getAsObject(i) ); if (notification != NULL) { result->push_back(notification); } } } return result; } void MapBooOLDBuilder::parseApplicationEventsJSON(const std::string& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser::instance()->parse(json, true); if (jsonBaseObject == NULL) { ILogger::instance()->logError("Can't parse ApplicationJSON from %s", url._path.c_str()); } else { const JSONArray* jsonArray = jsonBaseObject->asArray(); if (jsonArray != NULL) { const size_t size = jsonArray->size(); for (size_t i = 0; i < size; i++) { const JSONObject* jsonObject = jsonArray->getAsObject(i); parseApplicationJSON(jsonObject, url); } } else { parseApplicationJSON(json, url); } } delete jsonBaseObject; } void MapBooOLDBuilder::parseApplicationJSON(const JSONObject* jsonObject, const URL& url) { std::vector<std::string> errors; if (jsonObject == NULL) { ILogger::instance()->logError("Invalid ApplicationJSON"); } else { const JSONString* jsonError = jsonObject->getAsString("error"); if (jsonError == NULL) { const int eventId = (int) jsonObject->getAsNumber("eventId", 0); const int timestamp = (int) jsonObject->getAsNumber("timestamp", 0); if (getApplicationEventId() != eventId) { const JSONString* jsonName = jsonObject->getAsString("name"); if (jsonName != NULL) { setApplicationName( jsonName->value() ); } const JSONString* jsonWebsite = jsonObject->getAsString("website"); if (jsonWebsite != NULL) { setApplicationWebsite( jsonWebsite->value() ); } const JSONString* jsonEMail = jsonObject->getAsString("email"); if (jsonEMail != NULL) { setApplicationEMail( jsonEMail->value() ); } const JSONString* jsonAbout = jsonObject->getAsString("about"); if (jsonAbout != NULL) { setApplicationAbout( jsonAbout->value() ); } const JSONObject* jsonScene = jsonObject->getAsObject("scene"); if (jsonScene != NULL) { parseSceneEventAndUpdateScene(jsonScene); } const JSONArray* jsonAllScenes = jsonObject->getAsArray("scenes"); if (jsonAllScenes != NULL) { std::vector<MapBooOLD_Scene*> scenes; const size_t scenesCount = jsonAllScenes->size(); for (size_t i = 0; i < scenesCount; i++) { MapBooOLD_Scene* scene = parseScene( jsonAllScenes->getAsObject(i) ); if (scene != NULL) { scenes.push_back(scene); } } setApplicationScenes(scenes); } const JSONObject* jsonScenes = jsonObject->getAsObject("scenes"); if (jsonScenes != NULL) { const JSONObject* jsonPutScene = jsonScenes->getAsObject("putScene"); if (jsonPutScene != NULL) { const JSONNumber* jsonPosition = jsonPutScene->getAsNumber("position"); int position = (jsonPosition != NULL) ? (int) jsonPosition->value() : 0; const JSONObject* jsonNewScene = jsonPutScene->getAsObject("scene"); if (jsonNewScene != NULL) { MapBooOLD_Scene* scene = parseScene(jsonNewScene); if (scene != NULL) { addApplicationScene(scene, position); } } } else { const JSONObject* jsonDeleteScene = jsonScenes->getAsObject("deleteScene"); if (jsonDeleteScene != NULL) { const JSONString* jsonSceneId = jsonDeleteScene->getAsString("sceneId"); if (jsonSceneId != NULL) { deleteApplicationScene(jsonSceneId->value()); } } } } setApplicationEventId(eventId); setApplicationTimestamp(timestamp); saveApplicationData(); setHasParsedApplication(); } const JSONString* jsonCurrentSceneId = jsonObject->getAsString("currentSceneId"); if (jsonCurrentSceneId != NULL) { setApplicationCurrentSceneId( jsonCurrentSceneId->value() ); } if (_enableNotifications) { const JSONArray* jsonNotifications = jsonObject->getAsArray("notifications"); if (jsonNotifications != NULL) { addApplicationNotifications( parseNotifications(jsonNotifications) ); } const JSONObject* jsonNotification = jsonObject->getAsObject("notification"); if (jsonNotification != NULL) { addApplicationNotification( parseNotification(jsonNotification) ); } } if (_initialParse) { _initialParse = false; if (_applicationCurrentSceneId.compare("-1") == 0) { if (_applicationScenes.size() > 0) { setApplicationCurrentSceneId(_applicationScenes.at(0)->getId()); } } } } else { errors.push_back(jsonError->value().c_str()); ILogger::instance()->logError("Server Error: %s", jsonError->value().c_str()); if (_initialParse) { _initialParse = false; setHasParsedApplication(); } } } _mbErrorRenderer->setErrors(errors); } void MapBooOLDBuilder::parseApplicationJSON(const std::string& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser::instance()->parse(json, true); if (jsonBaseObject == NULL) { ILogger::instance()->logError("Can't parse ApplicationJSON from %s", url._path.c_str()); } else { const JSONObject* jsonObject = jsonBaseObject->asObject(); parseApplicationJSON(jsonObject, url); } delete jsonBaseObject; } void MapBooOLDBuilder::parseSceneEventAndUpdateScene(const JSONObject* jsonObject) { if (jsonObject == NULL) { return; } const JSONString* jsonSceneToBeUpdatedID = jsonObject->getAsString("id"); if (jsonSceneToBeUpdatedID == NULL) { return; } const std::string sceneToBeUpdatedID = jsonSceneToBeUpdatedID->value(); const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneID = _applicationScenes[i]->getId(); if (sceneID.compare(sceneToBeUpdatedID) == 0) { MapBooOLD_Scene* oldScene = _applicationScenes[i]; const std::string name = jsonObject->getAsString("name", oldScene->getName()); const std::string description = jsonObject->getAsString("description", oldScene->getDescription()); const JSONBaseObject* jboScreenshot = jsonObject->get("screenshot"); const MapBooOLD_MultiImage* screenshot; if (jboScreenshot != NULL) { screenshot = parseMultiImage(jboScreenshot->asObject()); } else { const MapBooOLD_MultiImage* oldScreenshot = oldScene->getScreenshot(); screenshot = (oldScreenshot != NULL) ? oldScreenshot->deepCopy() : NULL; } const JSONBaseObject* jboBackgroundColor = jsonObject->get("backgroundColor"); const Color backgroundColor = (jboBackgroundColor != NULL) ? parseColor(jboBackgroundColor->asString()) : oldScene->getBackgroundColor(); const JSONBaseObject* jboCameraPosition = jsonObject->get("cameraPosition"); const MapBooOLD_CameraPosition* cameraPosition; if (jboCameraPosition != NULL) { cameraPosition = parseCameraPosition(jboCameraPosition->asObject()); } else { const MapBooOLD_CameraPosition* oldCameraPosition = oldScene->getCameraPosition(); cameraPosition = (oldCameraPosition != NULL) ? new MapBooOLD_CameraPosition(oldCameraPosition->getPosition(), oldCameraPosition->getHeading(), oldCameraPosition->getPitch(), oldCameraPosition->isAnimated()) : NULL ; } const JSONBaseObject* jboSector = jsonObject->get("sector"); const Sector* sector; if (jboSector != NULL) { sector = parseSector(jboSector->asObject()); } else { const Sector* oldSector = oldScene->getSector(); sector = (oldSector != NULL) ? new Sector(oldSector->_lower, oldSector->_upper) : NULL; } const JSONBaseObject* jboBaseLayer = jsonObject->get("baseLayer"); Layer* baseLayer = (jboBaseLayer != NULL) ? parseLayer(jboBaseLayer->asObject()) : oldScene->getBaseLayer()->copy(); const JSONBaseObject* jboOverlayLayer = jsonObject->get("overlayLayer"); Layer* oldOverlayLayer = (oldScene->getOverlayLayer() != NULL) ? oldScene->getOverlayLayer()->copy() : NULL; Layer* overlayLayer = (jboOverlayLayer != NULL) ? parseLayer(jboOverlayLayer->asObject()) : oldOverlayLayer; const bool hasWarnings = jsonObject->getAsBoolean("hasWarnings", false); const bool queryable = jsonObject->getAsBoolean("queryable", oldScene->isQueryable()); const bool cameraPositionChaged = (jboCameraPosition != NULL); MapBooOLD_Scene* newScene = new MapBooOLD_Scene(sceneToBeUpdatedID, name, description, screenshot, backgroundColor, cameraPosition, sector, baseLayer, overlayLayer, queryable, hasWarnings); _applicationScenes[i] = newScene; if (sceneID.compare(_applicationCurrentSceneId) == 0) { updateVisibleScene(cameraPositionChaged); } if (_applicationListener != NULL) { _applicationListener->onSceneChanged(_context, newScene); } fireOnScenesChanged(); delete oldScene; break; } } } void MapBooOLDBuilder::addApplicationNotifications(const std::vector<MapBooOLD_Notification*>* notifications) { if (notifications == NULL) { return; } const size_t size = notifications->size(); for (size_t i = 0; i < size; i++) { MapBooOLD_Notification* notification = notifications->at(i); if (notification != NULL) { addApplicationNotification(notification); } } delete notifications; } void MapBooOLDBuilder::addApplicationNotification(MapBooOLD_Notification* notification) { if (_marksRenderer != NULL) { const std::string message = notification->getMessage(); const bool hasMessage = (message.size() > 0); const URL* iconURL = notification->getIconURL(); const Geodetic2D position = notification->getPosition(); bool newMark = false; if (hasMessage) { if (iconURL == NULL) { _marksRenderer->addMark( new Mark(message, Geodetic3D(position, 0), ABSOLUTE, 0) ); } else { _marksRenderer->addMark( new Mark(message, *iconURL, Geodetic3D(position, 0), ABSOLUTE, 0) ); } newMark = true; } else { if (iconURL != NULL) { _marksRenderer->addMark( new Mark(*iconURL, Geodetic3D(position, 0), ABSOLUTE, 0) ); newMark = true; } } if (newMark) { const MapBooOLD_CameraPosition* cameraPosition = notification->getCameraPosition(); if (cameraPosition != NULL) { setCameraPosition(cameraPosition, true); } } } delete notification; } void MapBooOLDBuilder::setApplicationCurrentSceneId(const std::string& currentSceneId) { if (_applicationCurrentSceneId.compare(currentSceneId) != 0) { const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneId = _applicationScenes[i]->getId(); if (sceneId.compare(currentSceneId) == 0) { _applicationCurrentSceneId = currentSceneId; changedCurrentScene(); break; } } } } LayerSet* MapBooOLD_Scene::createLayerSet() const { LayerSet* layerSet = new LayerSet(); if (_baseLayer != NULL) { layerSet->addLayer(_baseLayer->copy()); } if (_overlayLayer != NULL) { layerSet->addLayer(_overlayLayer->copy()); } return layerSet; } void MapBooOLDBuilder::recreateLayerSet() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); if (scene == NULL) { _layerSet->removeAllLayers(true); } else { LayerSet* newLayerSet = scene->createLayerSet(); if (!newLayerSet->isEquals(_layerSet)) { _layerSet->removeAllLayers(true); _layerSet->takeLayersFrom(newLayerSet); } delete newLayerSet; } } const URL MapBooOLDBuilder::createApplicationTubeURL() const { const std::string tubesPath = _tubesURL._path; std::string view; switch (_viewType) { case VIEW_PRESENTATION: view = "presentation"; break; case VIEW_EDITION_PREVIEW: view = "edition-preview"; break; default: view = "runtime"; } return URL(tubesPath + "/application/" + _applicationId + "/" + view, false); } class MapBooOLDBuilder_TubeWatchdogPeriodicalTask : public GTask { private: MapBooOLDBuilder* _builder; bool _firstRun; public: MapBooOLDBuilder_TubeWatchdogPeriodicalTask(MapBooOLDBuilder* builder) : _builder(builder), _firstRun(true) { } void run(const G3MContext* context) { if (_firstRun) { _firstRun = false; } else { if (!_builder->isApplicationTubeOpen()) { _builder->pollApplicationDataFromServer(context); _builder->openApplicationTube(context); } } } }; std::vector<PeriodicalTask*>* MapBooOLDBuilder::createPeriodicalTasks() { std::vector<PeriodicalTask*>* periodicalTasks = new std::vector<PeriodicalTask*>(); periodicalTasks->push_back(new PeriodicalTask(TimeInterval::fromSeconds(5), new MapBooOLDBuilder_TubeWatchdogPeriodicalTask(this))); return periodicalTasks; } IStorage* MapBooOLDBuilder::getStorage() { if (_storage == NULL) { _storage = createStorage(); } return _storage; } class MapBooOLDBuilder_ApplicationTubeListener : public IWebSocketListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeListener(MapBooOLDBuilder* builder) : _builder(builder) { } ~MapBooOLDBuilder_ApplicationTubeListener() { } void onOpen(IWebSocket* ws) { ILogger::instance()->logInfo("Tube '%s' opened!", ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(true); } void onError(IWebSocket* ws, const std::string& error) { ILogger::instance()->logError("Error '%s' on Tube '%s'", error.c_str(), ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(false); } void onMessage(IWebSocket* ws, const std::string& message) { _builder->parseApplicationJSON(message, ws->getURL()); } void onClose(IWebSocket* ws) { ILogger::instance()->logError("Tube '%s' closed!", ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(false); } }; class MapBooOLDBuilder_ApplicationTubeConnector : public GInitializationTask { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeConnector(MapBooOLDBuilder* builder) : _builder(builder) { } void run(const G3MContext* context) { _builder->setContext(context); _builder->openApplicationTube(context); } bool isDone(const G3MContext* context) { return _builder->hasParsedApplication(); } }; void MapBooOLDBuilder::setContext(const G3MContext* context) { _context = context; } MapBooOLDBuilder::~MapBooOLDBuilder() { } class MapBooOLDBuilder_RestJSON : public IBufferDownloadListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_RestJSON(MapBooOLDBuilder* builder) : _builder(builder) { } void onDownload(const URL& url, IByteBuffer* buffer, bool expired) { _builder->parseApplicationEventsJSON(buffer->getAsString(), url); delete buffer; } void onError(const URL& url) { ILogger::instance()->logError("Can't download %s", url._path.c_str()); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, bool expired) { } }; const URL MapBooOLDBuilder::createApplicationPollURL() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString(_serverURL._path); isb->addString("/poll/"); isb->addString(_applicationId); isb->addString("?view="); isb->addString(getViewAsString()); isb->addString("&eventId="); isb->addInt(_applicationEventId); const std::string path = isb->getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder::openApplicationTube(const G3MContext* context) { const IFactory* factory = context->getFactory(); _webSocket = factory->createWebSocket(createApplicationTubeURL(), new MapBooOLDBuilder_ApplicationTubeListener(this), true , true ); } const std::string MapBooOLDBuilder::getApplicationCurrentSceneId() { return _applicationCurrentSceneId; } const MapBooOLD_Scene* MapBooOLDBuilder::getApplicationCurrentScene() { const std::string currentSceneId = getApplicationCurrentSceneId(); const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneId = _applicationScenes[i]->getId(); if (sceneId.compare(currentSceneId) == 0) { return _applicationScenes[i]; } } return NULL; } Color MapBooOLDBuilder::getCurrentBackgroundColor() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); return (scene == NULL) ? Color::black() : scene->getBackgroundColor(); } MarksRenderer* MapBooOLDBuilder::getMarksRenderer() { if (_marksRenderer == NULL) { _marksRenderer = new MarksRenderer(false); } return _marksRenderer; } G3MWidget* MapBooOLDBuilder::create() { if (_g3mWidget != NULL) { ILogger::instance()->logError("The G3MWidget was already created, can't be created more than once"); return NULL; } CompositeRenderer* mainRenderer = new CompositeRenderer(); _mbErrorRenderer = new MapBooOLD_ErrorRenderer(); mainRenderer->addRenderer(_mbErrorRenderer); const Planet* planet = createPlanet(); PlanetRenderer* planetRenderer = createPlanetRenderer(); mainRenderer->addRenderer(planetRenderer); mainRenderer->addRenderer(getMarksRenderer()); std::vector<ICameraConstrainer*>* cameraConstraints = createCameraConstraints(planet, planetRenderer); GInitializationTask* initializationTask = new MapBooOLDBuilder_ApplicationTubeConnector(this); std::vector<PeriodicalTask*>* periodicalTasks = createPeriodicalTasks(); ICameraActivityListener* cameraActivityListener = NULL; InitialCameraPositionProvider* icpp = new SimpleInitialCameraPositionProvider(); MapBooOLD_HUDRenderer* hudRenderer = new MapBooOLD_HUDRenderer(); InfoDisplay* infoDisplay = new MapBooOLD_HUDRendererInfoDisplay(hudRenderer); infoDisplay->showDisplay(); _g3mWidget = G3MWidget::create(getGL(), getStorage(), getDownloader(), getThreadUtils(), cameraActivityListener, planet, *cameraConstraints, createCameraRenderer(), mainRenderer, createBusyRenderer(), createErrorRenderer(), hudRenderer, Color::black(), false, false, initializationTask, true, *periodicalTasks, getGPUProgramManager(), createSceneLighting(), icpp, infoDisplay, MONO); delete cameraConstraints; delete periodicalTasks; return _g3mWidget; } int MapBooOLDBuilder::getApplicationEventId() const { return _applicationEventId; } void MapBooOLDBuilder::setApplicationEventId(const int eventId) { _applicationEventId = eventId; } int MapBooOLDBuilder::getApplicationTimestamp() const { return _applicationTimestamp; } const std::string MapBooOLDBuilder::getApplicationId() { return _applicationId; } void MapBooOLDBuilder::saveApplicationData() const { } void MapBooOLDBuilder::setHasParsedApplication() { _hasParsedApplication = true; } bool MapBooOLDBuilder::hasParsedApplication() const { return _hasParsedApplication; } void MapBooOLDBuilder::setApplicationTimestamp(const int timestamp) { _applicationTimestamp = timestamp; } void MapBooOLDBuilder::setApplicationName(const std::string& name) { if (_applicationName.compare(name) != 0) { _applicationName = name; if (_applicationListener != NULL) { _applicationListener->onNameChanged(_context, _applicationName); } } } void MapBooOLDBuilder::setApplicationWebsite(const std::string& website) { if (_applicationWebsite.compare(website) != 0) { _applicationWebsite = website; if (_applicationListener != NULL) { _applicationListener->onWebsiteChanged(_context, _applicationWebsite); } } } void MapBooOLDBuilder::setApplicationEMail(const std::string& eMail) { if (_applicationEMail.compare(eMail) != 0) { _applicationEMail = eMail; if (_applicationListener != NULL) { _applicationListener->onEMailChanged(_context, _applicationEMail); } } } void MapBooOLDBuilder::setApplicationAbout(const std::string& about) { if (_applicationAbout.compare(about) != 0) { _applicationAbout = about; if (_applicationListener != NULL) { _applicationListener->onAboutChanged(_context, _applicationAbout); } } } class MapBooOLDBuilder_ChangeSceneTask : public GTask { private: MapBooOLDBuilder* _builder; const std::string _sceneId; public: MapBooOLDBuilder_ChangeSceneTask(MapBooOLDBuilder* builder, const std::string& sceneId) : _builder(builder), _sceneId(sceneId) { } void run(const G3MContext* context) { _builder->rawChangeScene(_sceneId); } }; void MapBooOLDBuilder::rawChangeScene(const std::string& sceneId) { _applicationCurrentSceneId = sceneId; changedCurrentScene(); } void MapBooOLDBuilder::changeScene(const std::string& sceneId) { const std::string currentSceneId = getApplicationCurrentSceneId(); if (currentSceneId.compare(sceneId) != 0) { const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string iSceneId = _applicationScenes[i]->getId(); if (sceneId.compare(iSceneId) == 0) { getThreadUtils()->invokeInRendererThread(new MapBooOLDBuilder_ChangeSceneTask(this, sceneId), true); break; } } } } void MapBooOLDBuilder::changeScene(const MapBooOLD_Scene* scene) { const size_t size = _applicationScenes.size(); for (size_t i = 0; i < size; i++) { if (_applicationScenes[i] == scene) { changeScene(scene->getId()); break; } } } class MapBooOLDBuilder_DummyListener : public IBufferDownloadListener { public: MapBooOLDBuilder_DummyListener() { } void onDownload(const URL& url, IByteBuffer* buffer, bool expired) { delete buffer; } void onError(const URL& url) { ILogger::instance()->logError("Can't download %s", url._path.c_str()); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, bool expired) { } }; void MapBooOLDBuilder::changedCurrentScene() { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != NULL) { _g3mWidget->setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget->resetPeriodicalTasksTimeouts(); if (currentScene != NULL) { const Sector* sector = currentScene->getSector(); if (sector == NULL) { _g3mWidget->setRenderedSector( Sector::fullSphere() ); } else { _g3mWidget->setRenderedSector( *sector ); } setCameraPosition(currentScene->getCameraPosition()); } } if (_applicationListener != NULL) { _applicationListener->onCurrentSceneChanged(_context, getApplicationCurrentSceneId(), currentScene); } if (_viewType == VIEW_EDITION_PREVIEW) { if (_applicationCurrentSceneId.compare(_lastApplicationCurrentSceneId) != 0) { if (_lastApplicationCurrentSceneId.compare("-1") != 0) { if (_webSocket != NULL && _isApplicationTubeOpen) { _webSocket->send( getApplicationCurrentSceneCommand() ); } else if (_token.length() > 0) { _g3mWidget->getG3MContext()->getDownloader()->requestBuffer(createApplicationCurrentSceneURL(), DownloadPriority::HIGHEST, TimeInterval::zero(), false, new MapBooOLDBuilder_DummyListener(), false); } else { ILogger::instance()->logError("VIEW_PRESENTATION: can't fire the event of changed scene"); } } _lastApplicationCurrentSceneId = _applicationCurrentSceneId; } } } const std::string MapBooOLDBuilder::getApplicationCurrentSceneCommand() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString("currentSceneId="); isb->addString(_applicationCurrentSceneId); const std::string s = isb->getString(); delete isb; return s; } const URL MapBooOLDBuilder::createApplicationCurrentSceneURL() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString(_serverURL._path); isb->addString("/REST/1/applications/"); isb->addString(_applicationId); isb->addString("/_POST_?"); isb->addString("currentSceneId="); isb->addString(_applicationCurrentSceneId); isb->addString("&token="); isb->addString(_token); const std::string path = isb->getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder::updateVisibleScene(const bool cameraPositionChanged) { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != NULL) { _g3mWidget->setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget->resetPeriodicalTasksTimeouts(); if (currentScene != NULL) { const Sector* sector = currentScene->getSector(); if (sector == NULL) { _g3mWidget->setRenderedSector( Sector::fullSphere() ); } else { _g3mWidget->setRenderedSector( *sector ); } if (cameraPositionChanged) { setCameraPosition(currentScene->getCameraPosition()); } } } } void MapBooOLDBuilder::setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition, const bool animated) { if (cameraPosition != NULL) { if (animated) { _g3mWidget->setAnimatedCameraPosition(TimeInterval::fromSeconds(3), cameraPosition->getPosition(), cameraPosition->getHeading(), cameraPosition->getPitch()); } else { _g3mWidget->setCameraPosition( cameraPosition->getPosition() ); _g3mWidget->setCameraHeading( cameraPosition->getHeading() ); _g3mWidget->setCameraPitch( cameraPosition->getPitch() ); } } } void MapBooOLDBuilder::setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition) { if (cameraPosition != NULL) { const bool animated = cameraPosition->isAnimated(); setCameraPosition(cameraPosition, animated); } } void MapBooOLDBuilder::fireOnScenesChanged() { if (_applicationListener != NULL) {_applicationListener.onScenesChanged(_context,
  //SimpleCameraConstrainer* scc = new SimpleCameraConstrainer();
  //cameraRenderer->addHandler(new CameraDoubleTapHandler());
  // defaults to OSM
//    result = URLTemplateLayer::newWGS84(urlTemplate,
//                                        sector,
//                                        transparent,
//                                        firstLevel,
//                                        maxLevel,
//                                        TimeInterval::fromDays(30));
//const std::string MapBooOLDBuilder::parseSceneId(const JSONObject* jsonObject) const {
//  if (jsonObject == NULL) {
//    ILogger::instance()->logError("Missing Scene ID");
//    return "";
//  }
//
//  return jsonObject->getAsString("$oid", "");
//}
  //  if (hasWarnings && (_viewType != VIEW_PRESENTATION)) {
  //    return NULL;
  //  }
    //ILogger::instance()->logInfo(message);
    // do nothing
    // do nothing
//  IDownloader* downloader = context->getDownloader();
//  downloader->requestBuffer(createApplicationRestURL(),
//                            DownloadPriority::HIGHEST,
//                            TimeInterval::zero(),
//                            false, // readExpired
//                            new MapBooOLDBuilder_RestJSON(this),
//                            true);
  //  std::string                _applicationId;
  //  std::string                _applicationName;
  //  std::string                _applicationWebsite;
  //  std::string                _applicationEMail;
  //  std::string                _applicationAbout;
  //  int                        _applicationTimestamp;
  //  std::vector<MapBooOLD_Scene*> _applicationScenes;
  //  int                        _applicationCurrentSceneIndex;
  //  int                        _lastApplicationCurrentSceneIndex;
///#warning Diego at work!
    // do nothing
    // do nothing
    // do nothing
    // force immediate execution of PeriodicalTasks
    // force immediate execution of PeriodicalTasks
                                         new java.util.ArrayList<MapBooOLD_Scene>(_applicationScenes));
<<<<<<< HEAD bool MapBooBuilder::onTerrainTouch(const G3MEventContext* ec, ======= bool MapBooOLDBuilder::onTerrainTouch(const G3MEventContext* ec, >>>>>>> 882166c33bdf9946c54ea507ad5e1c47fb3e83e0 const Vector2F& pixel, const Camera* camera, const Geodetic3D& position, const Tile* tile) { if (_applicationListener != NULL) { _applicationListener->onTerrainTouch(this, ec, pixel, camera, position, tile); } return true; } PlanetRenderer* MapBooOLDBuilder::createPlanetRenderer() { const bool skirted = true; TileTessellator* tessellator = new PlanetTileTessellator(skirted, Sector::fullSphere()); ElevationDataProvider* elevationDataProvider = NULL; const float verticalExaggeration = 1; TileTexturizer* texturizer = new DefaultTileTexturizer(new DownloaderImageBuilder(URL("http://www.mapboo.com/web/img/tileNotFound.jpg"))); const bool renderDebug = false; const bool forceFirstLevelTilesRenderOnStart = true; const bool incrementalTileQuality = false; const Quality quality = QUALITY_LOW; const TilesRenderParameters* parameters = new TilesRenderParameters(renderDebug, forceFirstLevelTilesRenderOnStart, incrementalTileQuality, quality); const bool showStatistics = false; long long tileDownloadPriority = DownloadPriority::HIGHER; const Sector renderedSector = Sector::fullSphere(); const bool renderTileMeshes = true; const bool logTilesPetitions = false; ChangedRendererInfoListener* changedRendererInfoListener = NULL; TouchEventType touchEventTypeOfTerrainTouchListener = DownUp; PlanetRenderer* result = new PlanetRenderer(tessellator, elevationDataProvider, true, verticalExaggeration, texturizer, _layerSet, parameters, showStatistics, tileDownloadPriority, renderedSector, renderTileMeshes, logTilesPetitions, changedRendererInfoListener, touchEventTypeOfTerrainTouchListener, getTileLODTester(), getTileVisibilityTester()); if (_enableNotifications) { result->addTerrainTouchListener(new MapBooOLDBuilder_TerrainTouchListener(this)); } return result; } const Planet* MapBooOLDBuilder::createPlanet() { return SphericalPlanet::createEarth(); } std::vector<ICameraConstrainer*>* MapBooOLDBuilder::createCameraConstraints(const Planet* planet, PlanetRenderer* planetRenderer) { std::vector<ICameraConstrainer*>* cameraConstraints = new std::vector<ICameraConstrainer*>; const Geodetic3D initialCameraPosition = planet->getDefaultCameraPosition(Sector::fullSphere()); cameraConstraints->push_back( new RenderedSectorCameraConstrainer(planetRenderer, initialCameraPosition._height * 1.2) ); return cameraConstraints; } CameraRenderer* MapBooOLDBuilder::createCameraRenderer() { CameraRenderer* cameraRenderer = new CameraRenderer(); const bool useInertia = true; cameraRenderer->addHandler(new CameraSingleDragHandler(useInertia)); cameraRenderer->addHandler(new CameraDoubleDragHandler()); cameraRenderer->addHandler(new CameraRotationHandler()); return cameraRenderer; } ProtoRenderer* MapBooOLDBuilder::createBusyRenderer() { return new BusyMeshRenderer(Color::newFromRGBA(0, 0, 0, 1)); } class Mapboo_ErrorMessagesCustomizer : public ErrorMessagesCustomizer { private: MapBooOLDBuilder* _mbBuilder; public: Mapboo_ErrorMessagesCustomizer(MapBooOLDBuilder* mbBuilder) { _mbBuilder = mbBuilder; } ~Mapboo_ErrorMessagesCustomizer() {} std::vector<std::string> customize(const std::vector<std::string>& errors) { std::vector<std::string> customizedErrorMessages; const IStringUtils* stringUtils = IStringUtils::instance(); const size_t errorsSize = errors.size(); const std::string appNotFound = "Invalid request: Application #" + _mbBuilder->getApplicationId() + " not found"; for (size_t i = 0; i < errorsSize; i++) { std::string error = errors.at(i); if (stringUtils->beginsWith(error, appNotFound)) { customizedErrorMessages.push_back("Oops, application not found!"); break; } customizedErrorMessages.push_back(error); } return customizedErrorMessages; } }; ErrorRenderer* MapBooOLDBuilder::createErrorRenderer() { return new HUDErrorRenderer(new Mapboo_ErrorMessagesCustomizer(this)); } MapQuestLayer* MapBooOLDBuilder::parseMapQuestLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string imagery = jsonLayer->getAsString("imagery", "<imagery not present>"); if (imagery.compare("OpenAerial") == 0) { return MapQuestLayer::newOpenAerial(timeToCache); } return MapQuestLayer::newOSM(timeToCache); } BingMapsLayer* MapBooOLDBuilder::parseBingMapsLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string key = jsonLayer->getAsString("key", ""); const std::string imagerySet = jsonLayer->getAsString("imagerySet", "Aerial"); return new BingMapsLayer(imagerySet, key, timeToCache, true, 2, 25, 1, NULL, new std::vector<const Info*>()); } CartoDBLayer* MapBooOLDBuilder::parseCartoDBLayer(const JSONObject* jsonLayer, const bool transparent, const TimeInterval& timeToCache) const { const std::string userName = jsonLayer->getAsString("userName", ""); const std::string table = jsonLayer->getAsString("table", ""); return new CartoDBLayer(userName, table, timeToCache, true, 1, transparent, NULL, new std::vector<const Info*>()); } MapBoxLayer* MapBooOLDBuilder::parseMapBoxLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string mapKey = jsonLayer->getAsString("mapKey", ""); return new MapBoxLayer(mapKey, timeToCache, true, 1, 19, 1, NULL, new std::vector<const Info*>()); } WMSLayer* MapBooOLDBuilder::parseWMSLayer(const JSONObject* jsonLayer, const bool transparent) const { const std::string mapLayer = jsonLayer->getAsString("layerName", ""); const URL mapServerURL = URL(jsonLayer->getAsString("server", ""), false); const std::string versionStr = jsonLayer->getAsString("version", ""); WMSServerVersion mapServerVersion = WMS_1_1_0; if (versionStr.compare("WMS_1_3_0") == 0) { mapServerVersion = WMS_1_3_0; } const std::string queryLayer = jsonLayer->getAsString("queryLayer", ""); const std::string style = jsonLayer->getAsString("style", ""); const URL queryServerURL = URL("", false); const WMSServerVersion queryServerVersion = mapServerVersion; const Sector sector = parseSector(jsonLayer, "validSector"); std::string imageFormat = jsonLayer->getAsString("imageFormat", "image/png"); const std::string srs = jsonLayer->getAsString("projection", "EPSG:4326"); LayerTilesRenderParameters* layerTilesRenderParameters = NULL; if (srs.compare("EPSG:4326") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters::createDefaultWGS84(0, 17); } else if (srs.compare("EPSG:3857") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters::createDefaultMercator(0, 17); } const double expiration = jsonLayer->getAsNumber("expiration", 0); const long long milliseconds = IMathUtils::instance()->round(expiration); const TimeInterval timeToCache = TimeInterval::fromMilliseconds(milliseconds); const bool readExpired = jsonLayer->getAsBoolean("acceptExpiration", false); return new WMSLayer(mapLayer, mapServerURL, mapServerVersion, queryLayer, queryServerURL, queryServerVersion, sector, imageFormat, srs, style, transparent, NULL, timeToCache, readExpired, layerTilesRenderParameters); } URLTemplateLayer* MapBooOLDBuilder::parseURLTemplateLayer(const JSONObject* jsonLayer, const bool transparent) const { const std::string urlTemplate = jsonLayer->getAsString("url", ""); const int firstLevel = (int) jsonLayer->getAsNumber("firstLevel", 1); const int maxLevel = (int) jsonLayer->getAsNumber("maxLevel", 19); const std::string projection = jsonLayer->getAsString("projection", "EPSG:3857"); const bool mercator = (projection == "EPSG:3857"); const Sector sector = parseSector(jsonLayer, "validSector"); URLTemplateLayer* result; if (mercator) { result = URLTemplateLayer::newMercator(urlTemplate, sector, transparent, firstLevel, maxLevel, TimeInterval::fromDays(30)); } else { result = new URLTemplateLayer(urlTemplate, sector, transparent, TimeInterval::fromDays(30), true, new LevelTileCondition(firstLevel, maxLevel), LayerTilesRenderParameters::createDefaultWGS84(sector, 1, maxLevel)); } return result; } Layer* MapBooOLDBuilder::parseLayer(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == NULL) { return NULL; } if (jsonBaseObjectLayer->asNull() != NULL) { return NULL; } const TimeInterval defaultTimeToCache = TimeInterval::fromDays(30); const JSONObject* jsonLayer = jsonBaseObjectLayer->asObject(); if (jsonLayer == NULL) { ILogger::instance()->logError("Layer is not a json object"); return NULL; } const bool transparent = jsonLayer->getAsBoolean("transparent", false); const std::string layerType = jsonLayer->getAsString("layer", "<layer not present>"); Layer* layer; if (layerType.compare("OSM") == 0) { layer = new OSMLayer(defaultTimeToCache, true, 2, 1, NULL, new std::vector<const Info*>()); } else if (layerType.compare("MapQuest") == 0) { layer = parseMapQuestLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("BingMaps") == 0) { layer = parseBingMapsLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("CartoDB") == 0) { layer = parseCartoDBLayer(jsonLayer, transparent, defaultTimeToCache); } else if (layerType.compare("MapBox") == 0) { layer = parseMapBoxLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("WMS") == 0) { layer = parseWMSLayer(jsonLayer, transparent); } else if (layerType.compare("URLTemplate") == 0) { layer = parseURLTemplateLayer(jsonLayer, transparent); } else { ILogger::instance()->logError("Unsupported layer type \"%s\"", layerType.c_str()); ILogger::instance()->logError("%s", jsonBaseObjectLayer->description().c_str()); return NULL; } const std::string layerAttribution = jsonLayer->getAsString("attribution", ""); if (layerAttribution.compare("") != 0) { layer->addInfo(new Info(layerAttribution)); } return layer; } Color MapBooOLDBuilder::parseColor(const JSONString* jsonColor) const { if (jsonColor == NULL) { return Color::black(); } const Color* color = Color::parse(jsonColor->value()); if (color == NULL) { ILogger::instance()->logError("Invalid format in attribute 'color' (%s)", jsonColor->value().c_str()); return Color::black(); } Color result(*color); delete color; return result; } MapBooOLD_MultiImage_Level* MapBooOLDBuilder::parseMultiImageLevel(const JSONObject* jsonObject) const { const JSONString* jsURL = jsonObject->getAsString("url"); if (jsURL == NULL) { return NULL; } const JSONNumber* jsWidth = jsonObject->getAsNumber("width"); if (jsWidth == NULL) { return NULL; } const JSONNumber* jsHeight = jsonObject->getAsNumber("height"); if (jsHeight == NULL) { return NULL; } return new MapBooOLD_MultiImage_Level(URL(_serverURL, "/images/" + jsURL->value()), (int) jsWidth->value(), (int) jsHeight->value()); } MapBooOLD_MultiImage* MapBooOLDBuilder::parseMultiImage(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } Color averageColor = parseColor( jsonObject->getAsString("averageColor") ); std::vector<MapBooOLD_MultiImage_Level*> levels; const JSONArray* jsLevels = jsonObject->getAsArray("levels"); if (jsLevels != NULL) { const size_t levelsCount = jsLevels->size(); for (size_t i = 0; i < levelsCount; i++) { MapBooOLD_MultiImage_Level* level = parseMultiImageLevel( jsLevels->getAsObject(i) ); if (level != NULL) { levels.push_back(level); } } } return new MapBooOLD_MultiImage(averageColor, levels); } const MapBooOLD_CameraPosition* MapBooOLDBuilder::parseCameraPosition(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } const double latitudeInDegress = jsonObject->getAsNumber("latitude", 0); const double longitudeInDegress = jsonObject->getAsNumber("longitude", 0); const double height = jsonObject->getAsNumber("height", 0); const double headingInDegrees = jsonObject->getAsNumber("heading", 0); const double pitchInDegrees = jsonObject->getAsNumber("pitch", 0); const bool animated = jsonObject->getAsBoolean("animated", true); return new MapBooOLD_CameraPosition(Geodetic3D::fromDegrees(latitudeInDegress, longitudeInDegress, height), Angle::fromDegrees(headingInDegrees), Angle::fromDegrees(pitchInDegrees), animated); } Sector* MapBooOLDBuilder::parseSector(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == NULL) { return NULL; } if (jsonBaseObjectLayer->asNull() != NULL) { return NULL; } const JSONObject* jsonObject = jsonBaseObjectLayer->asObject(); if (jsonObject == NULL) { return NULL; } const double lowerLat = jsonObject->getAsNumber("lowerLat", -90.0); const double lowerLon = jsonObject->getAsNumber("lowerLon", -180.0); const double upperLat = jsonObject->getAsNumber("upperLat", 90.0); const double upperLon = jsonObject->getAsNumber("upperLon", 180.0); return new Sector(Geodetic2D::fromDegrees(lowerLat, lowerLon), Geodetic2D::fromDegrees(upperLat, upperLon)); } const Sector MapBooOLDBuilder::parseSector(const JSONObject* jsonObject, const std::string& paramName) const { const JSONObject* sector = jsonObject->getAsObject(paramName); if (sector == NULL) { return Sector::fullSphere(); } if (sector->asNull() != NULL) { return Sector::fullSphere(); } const double lowerLat = sector->getAsNumber("lowerLat", -90.0); const double lowerLon = sector->getAsNumber("lowerLon", -180.0); const double upperLat = sector->getAsNumber("upperLat", 90.0); const double upperLon = sector->getAsNumber("upperLon", 180.0); return Sector(Geodetic2D::fromDegrees(lowerLat, lowerLon), Geodetic2D::fromDegrees(upperLat, upperLon)); } MapBooOLD_Scene* MapBooOLDBuilder::parseScene(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } const bool hasWarnings = jsonObject->getAsBoolean("hasWarnings", false); const bool queryable = jsonObject->getAsBoolean("queryable", false); return new MapBooOLD_Scene(jsonObject->getAsString("id", ""), jsonObject->getAsString("name", ""), jsonObject->getAsString("description", ""), parseMultiImage( jsonObject->getAsObject("screenshot") ), parseColor( jsonObject->getAsString("backgroundColor") ), parseCameraPosition( jsonObject->getAsObject("cameraPosition") ), parseSector( jsonObject->get("sector") ), parseLayer( jsonObject->get("baseLayer") ), parseLayer( jsonObject->get("overlayLayer") ), queryable, hasWarnings); } const URL* MapBooOLDBuilder::parseURL(const JSONString* jsonString) const { if (jsonString == NULL) { return NULL; } return new URL(jsonString->value()); } MapBooOLD_Notification* MapBooOLDBuilder::parseNotification(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } return new MapBooOLD_Notification(Geodetic2D::fromDegrees(jsonObject->getAsNumber("latitude", 0), jsonObject->getAsNumber("longitude", 0)), parseCameraPosition( jsonObject->getAsObject("cameraPosition") ), jsonObject->getAsString("message", ""), parseURL( jsonObject->getAsString("iconURL") ) ); } std::vector<MapBooOLD_Notification*>* MapBooOLDBuilder::parseNotifications(const JSONArray* jsonArray) const { std::vector<MapBooOLD_Notification*>* result = new std::vector<MapBooOLD_Notification*>(); if (jsonArray != NULL) { const size_t size = jsonArray->size(); for (size_t i = 0; i < size; i++) { MapBooOLD_Notification* notification = parseNotification( jsonArray->getAsObject(i) ); if (notification != NULL) { result->push_back(notification); } } } return result; } void MapBooOLDBuilder::parseApplicationEventsJSON(const std::string& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser::instance()->parse(json, true); if (jsonBaseObject == NULL) { ILogger::instance()->logError("Can't parse ApplicationJSON from %s", url._path.c_str()); } else { const JSONArray* jsonArray = jsonBaseObject->asArray(); if (jsonArray != NULL) { const size_t size = jsonArray->size(); for (size_t i = 0; i < size; i++) { const JSONObject* jsonObject = jsonArray->getAsObject(i); parseApplicationJSON(jsonObject, url); } } else { parseApplicationJSON(json, url); } } delete jsonBaseObject; } void MapBooOLDBuilder::parseApplicationJSON(const JSONObject* jsonObject, const URL& url) { std::vector<std::string> errors; if (jsonObject == NULL) { ILogger::instance()->logError("Invalid ApplicationJSON"); } else { const JSONString* jsonError = jsonObject->getAsString("error"); if (jsonError == NULL) { const int eventId = (int) jsonObject->getAsNumber("eventId", 0); const int timestamp = (int) jsonObject->getAsNumber("timestamp", 0); if (getApplicationEventId() != eventId) { const JSONString* jsonName = jsonObject->getAsString("name"); if (jsonName != NULL) { setApplicationName( jsonName->value() ); } const JSONString* jsonWebsite = jsonObject->getAsString("website"); if (jsonWebsite != NULL) { setApplicationWebsite( jsonWebsite->value() ); } const JSONString* jsonEMail = jsonObject->getAsString("email"); if (jsonEMail != NULL) { setApplicationEMail( jsonEMail->value() ); } const JSONString* jsonAbout = jsonObject->getAsString("about"); if (jsonAbout != NULL) { setApplicationAbout( jsonAbout->value() ); } const JSONObject* jsonScene = jsonObject->getAsObject("scene"); if (jsonScene != NULL) { parseSceneEventAndUpdateScene(jsonScene); } const JSONArray* jsonAllScenes = jsonObject->getAsArray("scenes"); if (jsonAllScenes != NULL) { std::vector<MapBooOLD_Scene*> scenes; const size_t scenesCount = jsonAllScenes->size(); for (size_t i = 0; i < scenesCount; i++) { MapBooOLD_Scene* scene = parseScene( jsonAllScenes->getAsObject(i) ); if (scene != NULL) { scenes.push_back(scene); } } setApplicationScenes(scenes); } const JSONObject* jsonScenes = jsonObject->getAsObject("scenes"); if (jsonScenes != NULL) { const JSONObject* jsonPutScene = jsonScenes->getAsObject("putScene"); if (jsonPutScene != NULL) { const JSONNumber* jsonPosition = jsonPutScene->getAsNumber("position"); int position = (jsonPosition != NULL) ? (int) jsonPosition->value() : 0; const JSONObject* jsonNewScene = jsonPutScene->getAsObject("scene"); if (jsonNewScene != NULL) { MapBooOLD_Scene* scene = parseScene(jsonNewScene); if (scene != NULL) { addApplicationScene(scene, position); } } } else { const JSONObject* jsonDeleteScene = jsonScenes->getAsObject("deleteScene"); if (jsonDeleteScene != NULL) { const JSONString* jsonSceneId = jsonDeleteScene->getAsString("sceneId"); if (jsonSceneId != NULL) { deleteApplicationScene(jsonSceneId->value()); } } } } setApplicationEventId(eventId); setApplicationTimestamp(timestamp); saveApplicationData(); setHasParsedApplication(); } const JSONString* jsonCurrentSceneId = jsonObject->getAsString("currentSceneId"); if (jsonCurrentSceneId != NULL) { setApplicationCurrentSceneId( jsonCurrentSceneId->value() ); } if (_enableNotifications) { const JSONArray* jsonNotifications = jsonObject->getAsArray("notifications"); if (jsonNotifications != NULL) { addApplicationNotifications( parseNotifications(jsonNotifications) ); } const JSONObject* jsonNotification = jsonObject->getAsObject("notification"); if (jsonNotification != NULL) { addApplicationNotification( parseNotification(jsonNotification) ); } } if (_initialParse) { _initialParse = false; if (_applicationCurrentSceneId.compare("-1") == 0) { if (_applicationScenes.size() > 0) { setApplicationCurrentSceneId(_applicationScenes.at(0)->getId()); } } } } else { errors.push_back(jsonError->value().c_str()); ILogger::instance()->logError("Server Error: %s", jsonError->value().c_str()); if (_initialParse) { _initialParse = false; setHasParsedApplication(); } } } _mbErrorRenderer->setErrors(errors); } void MapBooOLDBuilder::parseApplicationJSON(const std::string& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser::instance()->parse(json, true); if (jsonBaseObject == NULL) { ILogger::instance()->logError("Can't parse ApplicationJSON from %s", url._path.c_str()); } else { const JSONObject* jsonObject = jsonBaseObject->asObject(); parseApplicationJSON(jsonObject, url); } delete jsonBaseObject; } void MapBooOLDBuilder::parseSceneEventAndUpdateScene(const JSONObject* jsonObject) { if (jsonObject == NULL) { return; } const JSONString* jsonSceneToBeUpdatedID = jsonObject->getAsString("id"); if (jsonSceneToBeUpdatedID == NULL) { return; } const std::string sceneToBeUpdatedID = jsonSceneToBeUpdatedID->value(); const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneID = _applicationScenes[i]->getId(); if (sceneID.compare(sceneToBeUpdatedID) == 0) { MapBooOLD_Scene* oldScene = _applicationScenes[i]; const std::string name = jsonObject->getAsString("name", oldScene->getName()); const std::string description = jsonObject->getAsString("description", oldScene->getDescription()); const JSONBaseObject* jboScreenshot = jsonObject->get("screenshot"); const MapBooOLD_MultiImage* screenshot; if (jboScreenshot != NULL) { screenshot = parseMultiImage(jboScreenshot->asObject()); } else { const MapBooOLD_MultiImage* oldScreenshot = oldScene->getScreenshot(); screenshot = (oldScreenshot != NULL) ? oldScreenshot->deepCopy() : NULL; } const JSONBaseObject* jboBackgroundColor = jsonObject->get("backgroundColor"); const Color backgroundColor = (jboBackgroundColor != NULL) ? parseColor(jboBackgroundColor->asString()) : oldScene->getBackgroundColor(); const JSONBaseObject* jboCameraPosition = jsonObject->get("cameraPosition"); const MapBooOLD_CameraPosition* cameraPosition; if (jboCameraPosition != NULL) { cameraPosition = parseCameraPosition(jboCameraPosition->asObject()); } else { const MapBooOLD_CameraPosition* oldCameraPosition = oldScene->getCameraPosition(); cameraPosition = (oldCameraPosition != NULL) ? new MapBooOLD_CameraPosition(oldCameraPosition->getPosition(), oldCameraPosition->getHeading(), oldCameraPosition->getPitch(), oldCameraPosition->isAnimated()) : NULL ; } const JSONBaseObject* jboSector = jsonObject->get("sector"); const Sector* sector; if (jboSector != NULL) { sector = parseSector(jboSector->asObject()); } else { const Sector* oldSector = oldScene->getSector(); sector = (oldSector != NULL) ? new Sector(oldSector->_lower, oldSector->_upper) : NULL; } const JSONBaseObject* jboBaseLayer = jsonObject->get("baseLayer"); Layer* baseLayer = (jboBaseLayer != NULL) ? parseLayer(jboBaseLayer->asObject()) : oldScene->getBaseLayer()->copy(); const JSONBaseObject* jboOverlayLayer = jsonObject->get("overlayLayer"); Layer* oldOverlayLayer = (oldScene->getOverlayLayer() != NULL) ? oldScene->getOverlayLayer()->copy() : NULL; Layer* overlayLayer = (jboOverlayLayer != NULL) ? parseLayer(jboOverlayLayer->asObject()) : oldOverlayLayer; const bool hasWarnings = jsonObject->getAsBoolean("hasWarnings", false); const bool queryable = jsonObject->getAsBoolean("queryable", oldScene->isQueryable()); const bool cameraPositionChaged = (jboCameraPosition != NULL); MapBooOLD_Scene* newScene = new MapBooOLD_Scene(sceneToBeUpdatedID, name, description, screenshot, backgroundColor, cameraPosition, sector, baseLayer, overlayLayer, queryable, hasWarnings); _applicationScenes[i] = newScene; if (sceneID.compare(_applicationCurrentSceneId) == 0) { updateVisibleScene(cameraPositionChaged); } if (_applicationListener != NULL) { _applicationListener->onSceneChanged(_context, newScene); } fireOnScenesChanged(); delete oldScene; break; } } } void MapBooOLDBuilder::addApplicationNotifications(const std::vector<MapBooOLD_Notification*>* notifications) { if (notifications == NULL) { return; } const size_t size = notifications->size(); for (size_t i = 0; i < size; i++) { MapBooOLD_Notification* notification = notifications->at(i); if (notification != NULL) { addApplicationNotification(notification); } } delete notifications; } void MapBooOLDBuilder::addApplicationNotification(MapBooOLD_Notification* notification) { if (_marksRenderer != NULL) { const std::string message = notification->getMessage(); const bool hasMessage = (message.size() > 0); const URL* iconURL = notification->getIconURL(); const Geodetic2D position = notification->getPosition(); bool newMark = false; if (hasMessage) { if (iconURL == NULL) { _marksRenderer->addMark( new Mark(message, Geodetic3D(position, 0), ABSOLUTE, 0) ); } else { _marksRenderer->addMark( new Mark(message, *iconURL, Geodetic3D(position, 0), ABSOLUTE, 0) ); } newMark = true; } else { if (iconURL != NULL) { _marksRenderer->addMark( new Mark(*iconURL, Geodetic3D(position, 0), ABSOLUTE, 0) ); newMark = true; } } if (newMark) { const MapBooOLD_CameraPosition* cameraPosition = notification->getCameraPosition(); if (cameraPosition != NULL) { setCameraPosition(cameraPosition, true); } } } delete notification; } void MapBooOLDBuilder::setApplicationCurrentSceneId(const std::string& currentSceneId) { if (_applicationCurrentSceneId.compare(currentSceneId) != 0) { const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneId = _applicationScenes[i]->getId(); if (sceneId.compare(currentSceneId) == 0) { _applicationCurrentSceneId = currentSceneId; changedCurrentScene(); break; } } } } LayerSet* MapBooOLD_Scene::createLayerSet() const { LayerSet* layerSet = new LayerSet(); if (_baseLayer != NULL) { layerSet->addLayer(_baseLayer->copy()); } if (_overlayLayer != NULL) { layerSet->addLayer(_overlayLayer->copy()); } return layerSet; } void MapBooOLDBuilder::recreateLayerSet() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); if (scene == NULL) { _layerSet->removeAllLayers(true); } else { LayerSet* newLayerSet = scene->createLayerSet(); if (!newLayerSet->isEquals(_layerSet)) { _layerSet->removeAllLayers(true); _layerSet->takeLayersFrom(newLayerSet); } delete newLayerSet; } } const URL MapBooOLDBuilder::createApplicationTubeURL() const { const std::string tubesPath = _tubesURL._path; std::string view; switch (_viewType) { case VIEW_PRESENTATION: view = "presentation"; break; case VIEW_EDITION_PREVIEW: view = "edition-preview"; break; default: view = "runtime"; } return URL(tubesPath + "/application/" + _applicationId + "/" + view, false); } class MapBooOLDBuilder_TubeWatchdogPeriodicalTask : public GTask { private: MapBooOLDBuilder* _builder; bool _firstRun; public: MapBooOLDBuilder_TubeWatchdogPeriodicalTask(MapBooOLDBuilder* builder) : _builder(builder), _firstRun(true) { } void run(const G3MContext* context) { if (_firstRun) { _firstRun = false; } else { if (!_builder->isApplicationTubeOpen()) { _builder->pollApplicationDataFromServer(context); _builder->openApplicationTube(context); } } } }; std::vector<PeriodicalTask*>* MapBooOLDBuilder::createPeriodicalTasks() { std::vector<PeriodicalTask*>* periodicalTasks = new std::vector<PeriodicalTask*>(); periodicalTasks->push_back(new PeriodicalTask(TimeInterval::fromSeconds(5), new MapBooOLDBuilder_TubeWatchdogPeriodicalTask(this))); return periodicalTasks; } IStorage* MapBooOLDBuilder::getStorage() { if (_storage == NULL) { _storage = createStorage(); } return _storage; } class MapBooOLDBuilder_ApplicationTubeListener : public IWebSocketListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeListener(MapBooOLDBuilder* builder) : _builder(builder) { } ~MapBooOLDBuilder_ApplicationTubeListener() { } void onOpen(IWebSocket* ws) { ILogger::instance()->logInfo("Tube '%s' opened!", ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(true); } void onError(IWebSocket* ws, const std::string& error) { ILogger::instance()->logError("Error '%s' on Tube '%s'", error.c_str(), ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(false); } void onMessage(IWebSocket* ws, const std::string& message) { _builder->parseApplicationJSON(message, ws->getURL()); } void onClose(IWebSocket* ws) { ILogger::instance()->logError("Tube '%s' closed!", ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(false); } }; class MapBooOLDBuilder_ApplicationTubeConnector : public GInitializationTask { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeConnector(MapBooOLDBuilder* builder) : _builder(builder) { } void run(const G3MContext* context) { _builder->setContext(context); _builder->openApplicationTube(context); } bool isDone(const G3MContext* context) { return _builder->hasParsedApplication(); } }; void MapBooOLDBuilder::setContext(const G3MContext* context) { _context = context; } MapBooOLDBuilder::~MapBooOLDBuilder() { } class MapBooOLDBuilder_RestJSON : public IBufferDownloadListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_RestJSON(MapBooOLDBuilder* builder) : _builder(builder) { } void onDownload(const URL& url, IByteBuffer* buffer, bool expired) { _builder->parseApplicationEventsJSON(buffer->getAsString(), url); delete buffer; } void onError(const URL& url) { ILogger::instance()->logError("Can't download %s", url._path.c_str()); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, bool expired) { } }; const URL MapBooOLDBuilder::createApplicationPollURL() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString(_serverURL._path); isb->addString("/poll/"); isb->addString(_applicationId); isb->addString("?view="); isb->addString(getViewAsString()); isb->addString("&eventId="); isb->addInt(_applicationEventId); const std::string path = isb->getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder::openApplicationTube(const G3MContext* context) { const IFactory* factory = context->getFactory(); _webSocket = factory->createWebSocket(createApplicationTubeURL(), new MapBooOLDBuilder_ApplicationTubeListener(this), true , true ); } const std::string MapBooOLDBuilder::getApplicationCurrentSceneId() { return _applicationCurrentSceneId; } const MapBooOLD_Scene* MapBooOLDBuilder::getApplicationCurrentScene() { const std::string currentSceneId = getApplicationCurrentSceneId(); const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneId = _applicationScenes[i]->getId(); if (sceneId.compare(currentSceneId) == 0) { return _applicationScenes[i]; } } return NULL; } Color MapBooOLDBuilder::getCurrentBackgroundColor() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); return (scene == NULL) ? Color::black() : scene->getBackgroundColor(); } MarksRenderer* MapBooOLDBuilder::getMarksRenderer() { if (_marksRenderer == NULL) { _marksRenderer = new MarksRenderer(false); } return _marksRenderer; } G3MWidget* MapBooOLDBuilder::create() { if (_g3mWidget != NULL) { ILogger::instance()->logError("The G3MWidget was already created, can't be created more than once"); return NULL; } CompositeRenderer* mainRenderer = new CompositeRenderer(); _mbErrorRenderer = new MapBooOLD_ErrorRenderer(); mainRenderer->addRenderer(_mbErrorRenderer); const Planet* planet = createPlanet(); PlanetRenderer* planetRenderer = createPlanetRenderer(); mainRenderer->addRenderer(planetRenderer); mainRenderer->addRenderer(getMarksRenderer()); std::vector<ICameraConstrainer*>* cameraConstraints = createCameraConstraints(planet, planetRenderer); GInitializationTask* initializationTask = new MapBooOLDBuilder_ApplicationTubeConnector(this); std::vector<PeriodicalTask*>* periodicalTasks = createPeriodicalTasks(); ICameraActivityListener* cameraActivityListener = NULL; InitialCameraPositionProvider* icpp = new SimpleInitialCameraPositionProvider(); MapBooOLD_HUDRenderer* hudRenderer = new MapBooOLD_HUDRenderer(); InfoDisplay* infoDisplay = new MapBooOLD_HUDRendererInfoDisplay(hudRenderer); infoDisplay->showDisplay(); _g3mWidget = G3MWidget::create(getGL(), getStorage(), getDownloader(), getThreadUtils(), cameraActivityListener, planet, *cameraConstraints, createCameraRenderer(), mainRenderer, createBusyRenderer(), createErrorRenderer(), hudRenderer, Color::black(), false, false, initializationTask, true, *periodicalTasks, getGPUProgramManager(), createSceneLighting(), icpp, infoDisplay, MONO); delete cameraConstraints; delete periodicalTasks; return _g3mWidget; } int MapBooOLDBuilder::getApplicationEventId() const { return _applicationEventId; } void MapBooOLDBuilder::setApplicationEventId(const int eventId) { _applicationEventId = eventId; } int MapBooOLDBuilder::getApplicationTimestamp() const { return _applicationTimestamp; } const std::string MapBooOLDBuilder::getApplicationId() { return _applicationId; } void MapBooOLDBuilder::saveApplicationData() const { } void MapBooOLDBuilder::setHasParsedApplication() { _hasParsedApplication = true; } bool MapBooOLDBuilder::hasParsedApplication() const { return _hasParsedApplication; } void MapBooOLDBuilder::setApplicationTimestamp(const int timestamp) { _applicationTimestamp = timestamp; } void MapBooOLDBuilder::setApplicationName(const std::string& name) { if (_applicationName.compare(name) != 0) { _applicationName = name; if (_applicationListener != NULL) { _applicationListener->onNameChanged(_context, _applicationName); } } } void MapBooOLDBuilder::setApplicationWebsite(const std::string& website) { if (_applicationWebsite.compare(website) != 0) { _applicationWebsite = website; if (_applicationListener != NULL) { _applicationListener->onWebsiteChanged(_context, _applicationWebsite); } } } void MapBooOLDBuilder::setApplicationEMail(const std::string& eMail) { if (_applicationEMail.compare(eMail) != 0) { _applicationEMail = eMail; if (_applicationListener != NULL) { _applicationListener->onEMailChanged(_context, _applicationEMail); } } } void MapBooOLDBuilder::setApplicationAbout(const std::string& about) { if (_applicationAbout.compare(about) != 0) { _applicationAbout = about; if (_applicationListener != NULL) { _applicationListener->onAboutChanged(_context, _applicationAbout); } } } class MapBooOLDBuilder_ChangeSceneTask : public GTask { private: MapBooOLDBuilder* _builder; const std::string _sceneId; public: MapBooOLDBuilder_ChangeSceneTask(MapBooOLDBuilder* builder, const std::string& sceneId) : _builder(builder), _sceneId(sceneId) { } void run(const G3MContext* context) { _builder->rawChangeScene(_sceneId); } }; void MapBooOLDBuilder::rawChangeScene(const std::string& sceneId) { _applicationCurrentSceneId = sceneId; changedCurrentScene(); } void MapBooOLDBuilder::changeScene(const std::string& sceneId) { const std::string currentSceneId = getApplicationCurrentSceneId(); if (currentSceneId.compare(sceneId) != 0) { const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string iSceneId = _applicationScenes[i]->getId(); if (sceneId.compare(iSceneId) == 0) { getThreadUtils()->invokeInRendererThread(new MapBooOLDBuilder_ChangeSceneTask(this, sceneId), true); break; } } } } void MapBooOLDBuilder::changeScene(const MapBooOLD_Scene* scene) { const size_t size = _applicationScenes.size(); for (size_t i = 0; i < size; i++) { if (_applicationScenes[i] == scene) { changeScene(scene->getId()); break; } } } class MapBooOLDBuilder_DummyListener : public IBufferDownloadListener { public: MapBooOLDBuilder_DummyListener() { } void onDownload(const URL& url, IByteBuffer* buffer, bool expired) { delete buffer; } void onError(const URL& url) { ILogger::instance()->logError("Can't download %s", url._path.c_str()); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, bool expired) { } }; void MapBooOLDBuilder::changedCurrentScene() { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != NULL) { _g3mWidget->setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget->resetPeriodicalTasksTimeouts(); if (currentScene != NULL) { const Sector* sector = currentScene->getSector(); if (sector == NULL) { _g3mWidget->setRenderedSector( Sector::fullSphere() ); } else { _g3mWidget->setRenderedSector( *sector ); } setCameraPosition(currentScene->getCameraPosition()); } } if (_applicationListener != NULL) { _applicationListener->onCurrentSceneChanged(_context, getApplicationCurrentSceneId(), currentScene); } if (_viewType == VIEW_EDITION_PREVIEW) { if (_applicationCurrentSceneId.compare(_lastApplicationCurrentSceneId) != 0) { if (_lastApplicationCurrentSceneId.compare("-1") != 0) { if (_webSocket != NULL && _isApplicationTubeOpen) { _webSocket->send( getApplicationCurrentSceneCommand() ); } else if (_token.length() > 0) { _g3mWidget->getG3MContext()->getDownloader()->requestBuffer(createApplicationCurrentSceneURL(), DownloadPriority::HIGHEST, TimeInterval::zero(), false, new MapBooOLDBuilder_DummyListener(), false); } else { ILogger::instance()->logError("VIEW_PRESENTATION: can't fire the event of changed scene"); } } _lastApplicationCurrentSceneId = _applicationCurrentSceneId; } } } const std::string MapBooOLDBuilder::getApplicationCurrentSceneCommand() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString("currentSceneId="); isb->addString(_applicationCurrentSceneId); const std::string s = isb->getString(); delete isb; return s; } const URL MapBooOLDBuilder::createApplicationCurrentSceneURL() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString(_serverURL._path); isb->addString("/REST/1/applications/"); isb->addString(_applicationId); isb->addString("/_POST_?"); isb->addString("currentSceneId="); isb->addString(_applicationCurrentSceneId); isb->addString("&token="); isb->addString(_token); const std::string path = isb->getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder::updateVisibleScene(const bool cameraPositionChanged) { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != NULL) { _g3mWidget->setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget->resetPeriodicalTasksTimeouts(); if (currentScene != NULL) { const Sector* sector = currentScene->getSector(); if (sector == NULL) { _g3mWidget->setRenderedSector( Sector::fullSphere() ); } else { _g3mWidget->setRenderedSector( *sector ); } if (cameraPositionChanged) { setCameraPosition(currentScene->getCameraPosition()); } } } } void MapBooOLDBuilder::setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition, const bool animated) { if (cameraPosition != NULL) { if (animated) { _g3mWidget->setAnimatedCameraPosition(TimeInterval::fromSeconds(3), cameraPosition->getPosition(), cameraPosition->getHeading(), cameraPosition->getPitch()); } else { _g3mWidget->setCameraPosition( cameraPosition->getPosition() ); _g3mWidget->setCameraHeading( cameraPosition->getHeading() ); _g3mWidget->setCameraPitch( cameraPosition->getPitch() ); } } } void MapBooOLDBuilder::setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition) { if (cameraPosition != NULL) { const bool animated = cameraPosition->isAnimated(); setCameraPosition(cameraPosition, animated); } } void MapBooOLDBuilder::fireOnScenesChanged() { if (_applicationListener != NULL) { } } void MapBooOLDBuilder::addApplicationScene(MapBooOLD_Scene* scene, const int position) {_applicationScenes.add(position, scene);
<<<<<<< HEAD bool MapBooBuilder::onTerrainTouch(const G3MEventContext* ec, ======= bool MapBooOLDBuilder::onTerrainTouch(const G3MEventContext* ec, >>>>>>> 882166c33bdf9946c54ea507ad5e1c47fb3e83e0 const Vector2F& pixel, const Camera* camera, const Geodetic3D& position, const Tile* tile) { if (_applicationListener != NULL) { _applicationListener->onTerrainTouch(this, ec, pixel, camera, position, tile); } return true; } PlanetRenderer* MapBooOLDBuilder::createPlanetRenderer() { const bool skirted = true; TileTessellator* tessellator = new PlanetTileTessellator(skirted, Sector::fullSphere()); ElevationDataProvider* elevationDataProvider = NULL; const float verticalExaggeration = 1; TileTexturizer* texturizer = new DefaultTileTexturizer(new DownloaderImageBuilder(URL("http://www.mapboo.com/web/img/tileNotFound.jpg"))); const bool renderDebug = false; const bool forceFirstLevelTilesRenderOnStart = true; const bool incrementalTileQuality = false; const Quality quality = QUALITY_LOW; const TilesRenderParameters* parameters = new TilesRenderParameters(renderDebug, forceFirstLevelTilesRenderOnStart, incrementalTileQuality, quality); const bool showStatistics = false; long long tileDownloadPriority = DownloadPriority::HIGHER; const Sector renderedSector = Sector::fullSphere(); const bool renderTileMeshes = true; const bool logTilesPetitions = false; ChangedRendererInfoListener* changedRendererInfoListener = NULL; TouchEventType touchEventTypeOfTerrainTouchListener = DownUp; PlanetRenderer* result = new PlanetRenderer(tessellator, elevationDataProvider, true, verticalExaggeration, texturizer, _layerSet, parameters, showStatistics, tileDownloadPriority, renderedSector, renderTileMeshes, logTilesPetitions, changedRendererInfoListener, touchEventTypeOfTerrainTouchListener, getTileLODTester(), getTileVisibilityTester()); if (_enableNotifications) { result->addTerrainTouchListener(new MapBooOLDBuilder_TerrainTouchListener(this)); } return result; } const Planet* MapBooOLDBuilder::createPlanet() { return SphericalPlanet::createEarth(); } std::vector<ICameraConstrainer*>* MapBooOLDBuilder::createCameraConstraints(const Planet* planet, PlanetRenderer* planetRenderer) { std::vector<ICameraConstrainer*>* cameraConstraints = new std::vector<ICameraConstrainer*>; const Geodetic3D initialCameraPosition = planet->getDefaultCameraPosition(Sector::fullSphere()); cameraConstraints->push_back( new RenderedSectorCameraConstrainer(planetRenderer, initialCameraPosition._height * 1.2) ); return cameraConstraints; } CameraRenderer* MapBooOLDBuilder::createCameraRenderer() { CameraRenderer* cameraRenderer = new CameraRenderer(); const bool useInertia = true; cameraRenderer->addHandler(new CameraSingleDragHandler(useInertia)); cameraRenderer->addHandler(new CameraDoubleDragHandler()); cameraRenderer->addHandler(new CameraRotationHandler()); return cameraRenderer; } ProtoRenderer* MapBooOLDBuilder::createBusyRenderer() { return new BusyMeshRenderer(Color::newFromRGBA(0, 0, 0, 1)); } class Mapboo_ErrorMessagesCustomizer : public ErrorMessagesCustomizer { private: MapBooOLDBuilder* _mbBuilder; public: Mapboo_ErrorMessagesCustomizer(MapBooOLDBuilder* mbBuilder) { _mbBuilder = mbBuilder; } ~Mapboo_ErrorMessagesCustomizer() {} std::vector<std::string> customize(const std::vector<std::string>& errors) { std::vector<std::string> customizedErrorMessages; const IStringUtils* stringUtils = IStringUtils::instance(); const size_t errorsSize = errors.size(); const std::string appNotFound = "Invalid request: Application #" + _mbBuilder->getApplicationId() + " not found"; for (size_t i = 0; i < errorsSize; i++) { std::string error = errors.at(i); if (stringUtils->beginsWith(error, appNotFound)) { customizedErrorMessages.push_back("Oops, application not found!"); break; } customizedErrorMessages.push_back(error); } return customizedErrorMessages; } }; ErrorRenderer* MapBooOLDBuilder::createErrorRenderer() { return new HUDErrorRenderer(new Mapboo_ErrorMessagesCustomizer(this)); } MapQuestLayer* MapBooOLDBuilder::parseMapQuestLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string imagery = jsonLayer->getAsString("imagery", "<imagery not present>"); if (imagery.compare("OpenAerial") == 0) { return MapQuestLayer::newOpenAerial(timeToCache); } return MapQuestLayer::newOSM(timeToCache); } BingMapsLayer* MapBooOLDBuilder::parseBingMapsLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string key = jsonLayer->getAsString("key", ""); const std::string imagerySet = jsonLayer->getAsString("imagerySet", "Aerial"); return new BingMapsLayer(imagerySet, key, timeToCache, true, 2, 25, 1, NULL, new std::vector<const Info*>()); } CartoDBLayer* MapBooOLDBuilder::parseCartoDBLayer(const JSONObject* jsonLayer, const bool transparent, const TimeInterval& timeToCache) const { const std::string userName = jsonLayer->getAsString("userName", ""); const std::string table = jsonLayer->getAsString("table", ""); return new CartoDBLayer(userName, table, timeToCache, true, 1, transparent, NULL, new std::vector<const Info*>()); } MapBoxLayer* MapBooOLDBuilder::parseMapBoxLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string mapKey = jsonLayer->getAsString("mapKey", ""); return new MapBoxLayer(mapKey, timeToCache, true, 1, 19, 1, NULL, new std::vector<const Info*>()); } WMSLayer* MapBooOLDBuilder::parseWMSLayer(const JSONObject* jsonLayer, const bool transparent) const { const std::string mapLayer = jsonLayer->getAsString("layerName", ""); const URL mapServerURL = URL(jsonLayer->getAsString("server", ""), false); const std::string versionStr = jsonLayer->getAsString("version", ""); WMSServerVersion mapServerVersion = WMS_1_1_0; if (versionStr.compare("WMS_1_3_0") == 0) { mapServerVersion = WMS_1_3_0; } const std::string queryLayer = jsonLayer->getAsString("queryLayer", ""); const std::string style = jsonLayer->getAsString("style", ""); const URL queryServerURL = URL("", false); const WMSServerVersion queryServerVersion = mapServerVersion; const Sector sector = parseSector(jsonLayer, "validSector"); std::string imageFormat = jsonLayer->getAsString("imageFormat", "image/png"); const std::string srs = jsonLayer->getAsString("projection", "EPSG:4326"); LayerTilesRenderParameters* layerTilesRenderParameters = NULL; if (srs.compare("EPSG:4326") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters::createDefaultWGS84(0, 17); } else if (srs.compare("EPSG:3857") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters::createDefaultMercator(0, 17); } const double expiration = jsonLayer->getAsNumber("expiration", 0); const long long milliseconds = IMathUtils::instance()->round(expiration); const TimeInterval timeToCache = TimeInterval::fromMilliseconds(milliseconds); const bool readExpired = jsonLayer->getAsBoolean("acceptExpiration", false); return new WMSLayer(mapLayer, mapServerURL, mapServerVersion, queryLayer, queryServerURL, queryServerVersion, sector, imageFormat, srs, style, transparent, NULL, timeToCache, readExpired, layerTilesRenderParameters); } URLTemplateLayer* MapBooOLDBuilder::parseURLTemplateLayer(const JSONObject* jsonLayer, const bool transparent) const { const std::string urlTemplate = jsonLayer->getAsString("url", ""); const int firstLevel = (int) jsonLayer->getAsNumber("firstLevel", 1); const int maxLevel = (int) jsonLayer->getAsNumber("maxLevel", 19); const std::string projection = jsonLayer->getAsString("projection", "EPSG:3857"); const bool mercator = (projection == "EPSG:3857"); const Sector sector = parseSector(jsonLayer, "validSector"); URLTemplateLayer* result; if (mercator) { result = URLTemplateLayer::newMercator(urlTemplate, sector, transparent, firstLevel, maxLevel, TimeInterval::fromDays(30)); } else { result = new URLTemplateLayer(urlTemplate, sector, transparent, TimeInterval::fromDays(30), true, new LevelTileCondition(firstLevel, maxLevel), LayerTilesRenderParameters::createDefaultWGS84(sector, 1, maxLevel)); } return result; } Layer* MapBooOLDBuilder::parseLayer(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == NULL) { return NULL; } if (jsonBaseObjectLayer->asNull() != NULL) { return NULL; } const TimeInterval defaultTimeToCache = TimeInterval::fromDays(30); const JSONObject* jsonLayer = jsonBaseObjectLayer->asObject(); if (jsonLayer == NULL) { ILogger::instance()->logError("Layer is not a json object"); return NULL; } const bool transparent = jsonLayer->getAsBoolean("transparent", false); const std::string layerType = jsonLayer->getAsString("layer", "<layer not present>"); Layer* layer; if (layerType.compare("OSM") == 0) { layer = new OSMLayer(defaultTimeToCache, true, 2, 1, NULL, new std::vector<const Info*>()); } else if (layerType.compare("MapQuest") == 0) { layer = parseMapQuestLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("BingMaps") == 0) { layer = parseBingMapsLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("CartoDB") == 0) { layer = parseCartoDBLayer(jsonLayer, transparent, defaultTimeToCache); } else if (layerType.compare("MapBox") == 0) { layer = parseMapBoxLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("WMS") == 0) { layer = parseWMSLayer(jsonLayer, transparent); } else if (layerType.compare("URLTemplate") == 0) { layer = parseURLTemplateLayer(jsonLayer, transparent); } else { ILogger::instance()->logError("Unsupported layer type \"%s\"", layerType.c_str()); ILogger::instance()->logError("%s", jsonBaseObjectLayer->description().c_str()); return NULL; } const std::string layerAttribution = jsonLayer->getAsString("attribution", ""); if (layerAttribution.compare("") != 0) { layer->addInfo(new Info(layerAttribution)); } return layer; } Color MapBooOLDBuilder::parseColor(const JSONString* jsonColor) const { if (jsonColor == NULL) { return Color::black(); } const Color* color = Color::parse(jsonColor->value()); if (color == NULL) { ILogger::instance()->logError("Invalid format in attribute 'color' (%s)", jsonColor->value().c_str()); return Color::black(); } Color result(*color); delete color; return result; } MapBooOLD_MultiImage_Level* MapBooOLDBuilder::parseMultiImageLevel(const JSONObject* jsonObject) const { const JSONString* jsURL = jsonObject->getAsString("url"); if (jsURL == NULL) { return NULL; } const JSONNumber* jsWidth = jsonObject->getAsNumber("width"); if (jsWidth == NULL) { return NULL; } const JSONNumber* jsHeight = jsonObject->getAsNumber("height"); if (jsHeight == NULL) { return NULL; } return new MapBooOLD_MultiImage_Level(URL(_serverURL, "/images/" + jsURL->value()), (int) jsWidth->value(), (int) jsHeight->value()); } MapBooOLD_MultiImage* MapBooOLDBuilder::parseMultiImage(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } Color averageColor = parseColor( jsonObject->getAsString("averageColor") ); std::vector<MapBooOLD_MultiImage_Level*> levels; const JSONArray* jsLevels = jsonObject->getAsArray("levels"); if (jsLevels != NULL) { const size_t levelsCount = jsLevels->size(); for (size_t i = 0; i < levelsCount; i++) { MapBooOLD_MultiImage_Level* level = parseMultiImageLevel( jsLevels->getAsObject(i) ); if (level != NULL) { levels.push_back(level); } } } return new MapBooOLD_MultiImage(averageColor, levels); } const MapBooOLD_CameraPosition* MapBooOLDBuilder::parseCameraPosition(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } const double latitudeInDegress = jsonObject->getAsNumber("latitude", 0); const double longitudeInDegress = jsonObject->getAsNumber("longitude", 0); const double height = jsonObject->getAsNumber("height", 0); const double headingInDegrees = jsonObject->getAsNumber("heading", 0); const double pitchInDegrees = jsonObject->getAsNumber("pitch", 0); const bool animated = jsonObject->getAsBoolean("animated", true); return new MapBooOLD_CameraPosition(Geodetic3D::fromDegrees(latitudeInDegress, longitudeInDegress, height), Angle::fromDegrees(headingInDegrees), Angle::fromDegrees(pitchInDegrees), animated); } Sector* MapBooOLDBuilder::parseSector(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == NULL) { return NULL; } if (jsonBaseObjectLayer->asNull() != NULL) { return NULL; } const JSONObject* jsonObject = jsonBaseObjectLayer->asObject(); if (jsonObject == NULL) { return NULL; } const double lowerLat = jsonObject->getAsNumber("lowerLat", -90.0); const double lowerLon = jsonObject->getAsNumber("lowerLon", -180.0); const double upperLat = jsonObject->getAsNumber("upperLat", 90.0); const double upperLon = jsonObject->getAsNumber("upperLon", 180.0); return new Sector(Geodetic2D::fromDegrees(lowerLat, lowerLon), Geodetic2D::fromDegrees(upperLat, upperLon)); } const Sector MapBooOLDBuilder::parseSector(const JSONObject* jsonObject, const std::string& paramName) const { const JSONObject* sector = jsonObject->getAsObject(paramName); if (sector == NULL) { return Sector::fullSphere(); } if (sector->asNull() != NULL) { return Sector::fullSphere(); } const double lowerLat = sector->getAsNumber("lowerLat", -90.0); const double lowerLon = sector->getAsNumber("lowerLon", -180.0); const double upperLat = sector->getAsNumber("upperLat", 90.0); const double upperLon = sector->getAsNumber("upperLon", 180.0); return Sector(Geodetic2D::fromDegrees(lowerLat, lowerLon), Geodetic2D::fromDegrees(upperLat, upperLon)); } MapBooOLD_Scene* MapBooOLDBuilder::parseScene(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } const bool hasWarnings = jsonObject->getAsBoolean("hasWarnings", false); const bool queryable = jsonObject->getAsBoolean("queryable", false); return new MapBooOLD_Scene(jsonObject->getAsString("id", ""), jsonObject->getAsString("name", ""), jsonObject->getAsString("description", ""), parseMultiImage( jsonObject->getAsObject("screenshot") ), parseColor( jsonObject->getAsString("backgroundColor") ), parseCameraPosition( jsonObject->getAsObject("cameraPosition") ), parseSector( jsonObject->get("sector") ), parseLayer( jsonObject->get("baseLayer") ), parseLayer( jsonObject->get("overlayLayer") ), queryable, hasWarnings); } const URL* MapBooOLDBuilder::parseURL(const JSONString* jsonString) const { if (jsonString == NULL) { return NULL; } return new URL(jsonString->value()); } MapBooOLD_Notification* MapBooOLDBuilder::parseNotification(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } return new MapBooOLD_Notification(Geodetic2D::fromDegrees(jsonObject->getAsNumber("latitude", 0), jsonObject->getAsNumber("longitude", 0)), parseCameraPosition( jsonObject->getAsObject("cameraPosition") ), jsonObject->getAsString("message", ""), parseURL( jsonObject->getAsString("iconURL") ) ); } std::vector<MapBooOLD_Notification*>* MapBooOLDBuilder::parseNotifications(const JSONArray* jsonArray) const { std::vector<MapBooOLD_Notification*>* result = new std::vector<MapBooOLD_Notification*>(); if (jsonArray != NULL) { const size_t size = jsonArray->size(); for (size_t i = 0; i < size; i++) { MapBooOLD_Notification* notification = parseNotification( jsonArray->getAsObject(i) ); if (notification != NULL) { result->push_back(notification); } } } return result; } void MapBooOLDBuilder::parseApplicationEventsJSON(const std::string& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser::instance()->parse(json, true); if (jsonBaseObject == NULL) { ILogger::instance()->logError("Can't parse ApplicationJSON from %s", url._path.c_str()); } else { const JSONArray* jsonArray = jsonBaseObject->asArray(); if (jsonArray != NULL) { const size_t size = jsonArray->size(); for (size_t i = 0; i < size; i++) { const JSONObject* jsonObject = jsonArray->getAsObject(i); parseApplicationJSON(jsonObject, url); } } else { parseApplicationJSON(json, url); } } delete jsonBaseObject; } void MapBooOLDBuilder::parseApplicationJSON(const JSONObject* jsonObject, const URL& url) { std::vector<std::string> errors; if (jsonObject == NULL) { ILogger::instance()->logError("Invalid ApplicationJSON"); } else { const JSONString* jsonError = jsonObject->getAsString("error"); if (jsonError == NULL) { const int eventId = (int) jsonObject->getAsNumber("eventId", 0); const int timestamp = (int) jsonObject->getAsNumber("timestamp", 0); if (getApplicationEventId() != eventId) { const JSONString* jsonName = jsonObject->getAsString("name"); if (jsonName != NULL) { setApplicationName( jsonName->value() ); } const JSONString* jsonWebsite = jsonObject->getAsString("website"); if (jsonWebsite != NULL) { setApplicationWebsite( jsonWebsite->value() ); } const JSONString* jsonEMail = jsonObject->getAsString("email"); if (jsonEMail != NULL) { setApplicationEMail( jsonEMail->value() ); } const JSONString* jsonAbout = jsonObject->getAsString("about"); if (jsonAbout != NULL) { setApplicationAbout( jsonAbout->value() ); } const JSONObject* jsonScene = jsonObject->getAsObject("scene"); if (jsonScene != NULL) { parseSceneEventAndUpdateScene(jsonScene); } const JSONArray* jsonAllScenes = jsonObject->getAsArray("scenes"); if (jsonAllScenes != NULL) { std::vector<MapBooOLD_Scene*> scenes; const size_t scenesCount = jsonAllScenes->size(); for (size_t i = 0; i < scenesCount; i++) { MapBooOLD_Scene* scene = parseScene( jsonAllScenes->getAsObject(i) ); if (scene != NULL) { scenes.push_back(scene); } } setApplicationScenes(scenes); } const JSONObject* jsonScenes = jsonObject->getAsObject("scenes"); if (jsonScenes != NULL) { const JSONObject* jsonPutScene = jsonScenes->getAsObject("putScene"); if (jsonPutScene != NULL) { const JSONNumber* jsonPosition = jsonPutScene->getAsNumber("position"); int position = (jsonPosition != NULL) ? (int) jsonPosition->value() : 0; const JSONObject* jsonNewScene = jsonPutScene->getAsObject("scene"); if (jsonNewScene != NULL) { MapBooOLD_Scene* scene = parseScene(jsonNewScene); if (scene != NULL) { addApplicationScene(scene, position); } } } else { const JSONObject* jsonDeleteScene = jsonScenes->getAsObject("deleteScene"); if (jsonDeleteScene != NULL) { const JSONString* jsonSceneId = jsonDeleteScene->getAsString("sceneId"); if (jsonSceneId != NULL) { deleteApplicationScene(jsonSceneId->value()); } } } } setApplicationEventId(eventId); setApplicationTimestamp(timestamp); saveApplicationData(); setHasParsedApplication(); } const JSONString* jsonCurrentSceneId = jsonObject->getAsString("currentSceneId"); if (jsonCurrentSceneId != NULL) { setApplicationCurrentSceneId( jsonCurrentSceneId->value() ); } if (_enableNotifications) { const JSONArray* jsonNotifications = jsonObject->getAsArray("notifications"); if (jsonNotifications != NULL) { addApplicationNotifications( parseNotifications(jsonNotifications) ); } const JSONObject* jsonNotification = jsonObject->getAsObject("notification"); if (jsonNotification != NULL) { addApplicationNotification( parseNotification(jsonNotification) ); } } if (_initialParse) { _initialParse = false; if (_applicationCurrentSceneId.compare("-1") == 0) { if (_applicationScenes.size() > 0) { setApplicationCurrentSceneId(_applicationScenes.at(0)->getId()); } } } } else { errors.push_back(jsonError->value().c_str()); ILogger::instance()->logError("Server Error: %s", jsonError->value().c_str()); if (_initialParse) { _initialParse = false; setHasParsedApplication(); } } } _mbErrorRenderer->setErrors(errors); } void MapBooOLDBuilder::parseApplicationJSON(const std::string& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser::instance()->parse(json, true); if (jsonBaseObject == NULL) { ILogger::instance()->logError("Can't parse ApplicationJSON from %s", url._path.c_str()); } else { const JSONObject* jsonObject = jsonBaseObject->asObject(); parseApplicationJSON(jsonObject, url); } delete jsonBaseObject; } void MapBooOLDBuilder::parseSceneEventAndUpdateScene(const JSONObject* jsonObject) { if (jsonObject == NULL) { return; } const JSONString* jsonSceneToBeUpdatedID = jsonObject->getAsString("id"); if (jsonSceneToBeUpdatedID == NULL) { return; } const std::string sceneToBeUpdatedID = jsonSceneToBeUpdatedID->value(); const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneID = _applicationScenes[i]->getId(); if (sceneID.compare(sceneToBeUpdatedID) == 0) { MapBooOLD_Scene* oldScene = _applicationScenes[i]; const std::string name = jsonObject->getAsString("name", oldScene->getName()); const std::string description = jsonObject->getAsString("description", oldScene->getDescription()); const JSONBaseObject* jboScreenshot = jsonObject->get("screenshot"); const MapBooOLD_MultiImage* screenshot; if (jboScreenshot != NULL) { screenshot = parseMultiImage(jboScreenshot->asObject()); } else { const MapBooOLD_MultiImage* oldScreenshot = oldScene->getScreenshot(); screenshot = (oldScreenshot != NULL) ? oldScreenshot->deepCopy() : NULL; } const JSONBaseObject* jboBackgroundColor = jsonObject->get("backgroundColor"); const Color backgroundColor = (jboBackgroundColor != NULL) ? parseColor(jboBackgroundColor->asString()) : oldScene->getBackgroundColor(); const JSONBaseObject* jboCameraPosition = jsonObject->get("cameraPosition"); const MapBooOLD_CameraPosition* cameraPosition; if (jboCameraPosition != NULL) { cameraPosition = parseCameraPosition(jboCameraPosition->asObject()); } else { const MapBooOLD_CameraPosition* oldCameraPosition = oldScene->getCameraPosition(); cameraPosition = (oldCameraPosition != NULL) ? new MapBooOLD_CameraPosition(oldCameraPosition->getPosition(), oldCameraPosition->getHeading(), oldCameraPosition->getPitch(), oldCameraPosition->isAnimated()) : NULL ; } const JSONBaseObject* jboSector = jsonObject->get("sector"); const Sector* sector; if (jboSector != NULL) { sector = parseSector(jboSector->asObject()); } else { const Sector* oldSector = oldScene->getSector(); sector = (oldSector != NULL) ? new Sector(oldSector->_lower, oldSector->_upper) : NULL; } const JSONBaseObject* jboBaseLayer = jsonObject->get("baseLayer"); Layer* baseLayer = (jboBaseLayer != NULL) ? parseLayer(jboBaseLayer->asObject()) : oldScene->getBaseLayer()->copy(); const JSONBaseObject* jboOverlayLayer = jsonObject->get("overlayLayer"); Layer* oldOverlayLayer = (oldScene->getOverlayLayer() != NULL) ? oldScene->getOverlayLayer()->copy() : NULL; Layer* overlayLayer = (jboOverlayLayer != NULL) ? parseLayer(jboOverlayLayer->asObject()) : oldOverlayLayer; const bool hasWarnings = jsonObject->getAsBoolean("hasWarnings", false); const bool queryable = jsonObject->getAsBoolean("queryable", oldScene->isQueryable()); const bool cameraPositionChaged = (jboCameraPosition != NULL); MapBooOLD_Scene* newScene = new MapBooOLD_Scene(sceneToBeUpdatedID, name, description, screenshot, backgroundColor, cameraPosition, sector, baseLayer, overlayLayer, queryable, hasWarnings); _applicationScenes[i] = newScene; if (sceneID.compare(_applicationCurrentSceneId) == 0) { updateVisibleScene(cameraPositionChaged); } if (_applicationListener != NULL) { _applicationListener->onSceneChanged(_context, newScene); } fireOnScenesChanged(); delete oldScene; break; } } } void MapBooOLDBuilder::addApplicationNotifications(const std::vector<MapBooOLD_Notification*>* notifications) { if (notifications == NULL) { return; } const size_t size = notifications->size(); for (size_t i = 0; i < size; i++) { MapBooOLD_Notification* notification = notifications->at(i); if (notification != NULL) { addApplicationNotification(notification); } } delete notifications; } void MapBooOLDBuilder::addApplicationNotification(MapBooOLD_Notification* notification) { if (_marksRenderer != NULL) { const std::string message = notification->getMessage(); const bool hasMessage = (message.size() > 0); const URL* iconURL = notification->getIconURL(); const Geodetic2D position = notification->getPosition(); bool newMark = false; if (hasMessage) { if (iconURL == NULL) { _marksRenderer->addMark( new Mark(message, Geodetic3D(position, 0), ABSOLUTE, 0) ); } else { _marksRenderer->addMark( new Mark(message, *iconURL, Geodetic3D(position, 0), ABSOLUTE, 0) ); } newMark = true; } else { if (iconURL != NULL) { _marksRenderer->addMark( new Mark(*iconURL, Geodetic3D(position, 0), ABSOLUTE, 0) ); newMark = true; } } if (newMark) { const MapBooOLD_CameraPosition* cameraPosition = notification->getCameraPosition(); if (cameraPosition != NULL) { setCameraPosition(cameraPosition, true); } } } delete notification; } void MapBooOLDBuilder::setApplicationCurrentSceneId(const std::string& currentSceneId) { if (_applicationCurrentSceneId.compare(currentSceneId) != 0) { const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneId = _applicationScenes[i]->getId(); if (sceneId.compare(currentSceneId) == 0) { _applicationCurrentSceneId = currentSceneId; changedCurrentScene(); break; } } } } LayerSet* MapBooOLD_Scene::createLayerSet() const { LayerSet* layerSet = new LayerSet(); if (_baseLayer != NULL) { layerSet->addLayer(_baseLayer->copy()); } if (_overlayLayer != NULL) { layerSet->addLayer(_overlayLayer->copy()); } return layerSet; } void MapBooOLDBuilder::recreateLayerSet() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); if (scene == NULL) { _layerSet->removeAllLayers(true); } else { LayerSet* newLayerSet = scene->createLayerSet(); if (!newLayerSet->isEquals(_layerSet)) { _layerSet->removeAllLayers(true); _layerSet->takeLayersFrom(newLayerSet); } delete newLayerSet; } } const URL MapBooOLDBuilder::createApplicationTubeURL() const { const std::string tubesPath = _tubesURL._path; std::string view; switch (_viewType) { case VIEW_PRESENTATION: view = "presentation"; break; case VIEW_EDITION_PREVIEW: view = "edition-preview"; break; default: view = "runtime"; } return URL(tubesPath + "/application/" + _applicationId + "/" + view, false); } class MapBooOLDBuilder_TubeWatchdogPeriodicalTask : public GTask { private: MapBooOLDBuilder* _builder; bool _firstRun; public: MapBooOLDBuilder_TubeWatchdogPeriodicalTask(MapBooOLDBuilder* builder) : _builder(builder), _firstRun(true) { } void run(const G3MContext* context) { if (_firstRun) { _firstRun = false; } else { if (!_builder->isApplicationTubeOpen()) { _builder->pollApplicationDataFromServer(context); _builder->openApplicationTube(context); } } } }; std::vector<PeriodicalTask*>* MapBooOLDBuilder::createPeriodicalTasks() { std::vector<PeriodicalTask*>* periodicalTasks = new std::vector<PeriodicalTask*>(); periodicalTasks->push_back(new PeriodicalTask(TimeInterval::fromSeconds(5), new MapBooOLDBuilder_TubeWatchdogPeriodicalTask(this))); return periodicalTasks; } IStorage* MapBooOLDBuilder::getStorage() { if (_storage == NULL) { _storage = createStorage(); } return _storage; } class MapBooOLDBuilder_ApplicationTubeListener : public IWebSocketListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeListener(MapBooOLDBuilder* builder) : _builder(builder) { } ~MapBooOLDBuilder_ApplicationTubeListener() { } void onOpen(IWebSocket* ws) { ILogger::instance()->logInfo("Tube '%s' opened!", ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(true); } void onError(IWebSocket* ws, const std::string& error) { ILogger::instance()->logError("Error '%s' on Tube '%s'", error.c_str(), ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(false); } void onMessage(IWebSocket* ws, const std::string& message) { _builder->parseApplicationJSON(message, ws->getURL()); } void onClose(IWebSocket* ws) { ILogger::instance()->logError("Tube '%s' closed!", ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(false); } }; class MapBooOLDBuilder_ApplicationTubeConnector : public GInitializationTask { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeConnector(MapBooOLDBuilder* builder) : _builder(builder) { } void run(const G3MContext* context) { _builder->setContext(context); _builder->openApplicationTube(context); } bool isDone(const G3MContext* context) { return _builder->hasParsedApplication(); } }; void MapBooOLDBuilder::setContext(const G3MContext* context) { _context = context; } MapBooOLDBuilder::~MapBooOLDBuilder() { } class MapBooOLDBuilder_RestJSON : public IBufferDownloadListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_RestJSON(MapBooOLDBuilder* builder) : _builder(builder) { } void onDownload(const URL& url, IByteBuffer* buffer, bool expired) { _builder->parseApplicationEventsJSON(buffer->getAsString(), url); delete buffer; } void onError(const URL& url) { ILogger::instance()->logError("Can't download %s", url._path.c_str()); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, bool expired) { } }; const URL MapBooOLDBuilder::createApplicationPollURL() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString(_serverURL._path); isb->addString("/poll/"); isb->addString(_applicationId); isb->addString("?view="); isb->addString(getViewAsString()); isb->addString("&eventId="); isb->addInt(_applicationEventId); const std::string path = isb->getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder::openApplicationTube(const G3MContext* context) { const IFactory* factory = context->getFactory(); _webSocket = factory->createWebSocket(createApplicationTubeURL(), new MapBooOLDBuilder_ApplicationTubeListener(this), true , true ); } const std::string MapBooOLDBuilder::getApplicationCurrentSceneId() { return _applicationCurrentSceneId; } const MapBooOLD_Scene* MapBooOLDBuilder::getApplicationCurrentScene() { const std::string currentSceneId = getApplicationCurrentSceneId(); const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneId = _applicationScenes[i]->getId(); if (sceneId.compare(currentSceneId) == 0) { return _applicationScenes[i]; } } return NULL; } Color MapBooOLDBuilder::getCurrentBackgroundColor() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); return (scene == NULL) ? Color::black() : scene->getBackgroundColor(); } MarksRenderer* MapBooOLDBuilder::getMarksRenderer() { if (_marksRenderer == NULL) { _marksRenderer = new MarksRenderer(false); } return _marksRenderer; } G3MWidget* MapBooOLDBuilder::create() { if (_g3mWidget != NULL) { ILogger::instance()->logError("The G3MWidget was already created, can't be created more than once"); return NULL; } CompositeRenderer* mainRenderer = new CompositeRenderer(); _mbErrorRenderer = new MapBooOLD_ErrorRenderer(); mainRenderer->addRenderer(_mbErrorRenderer); const Planet* planet = createPlanet(); PlanetRenderer* planetRenderer = createPlanetRenderer(); mainRenderer->addRenderer(planetRenderer); mainRenderer->addRenderer(getMarksRenderer()); std::vector<ICameraConstrainer*>* cameraConstraints = createCameraConstraints(planet, planetRenderer); GInitializationTask* initializationTask = new MapBooOLDBuilder_ApplicationTubeConnector(this); std::vector<PeriodicalTask*>* periodicalTasks = createPeriodicalTasks(); ICameraActivityListener* cameraActivityListener = NULL; InitialCameraPositionProvider* icpp = new SimpleInitialCameraPositionProvider(); MapBooOLD_HUDRenderer* hudRenderer = new MapBooOLD_HUDRenderer(); InfoDisplay* infoDisplay = new MapBooOLD_HUDRendererInfoDisplay(hudRenderer); infoDisplay->showDisplay(); _g3mWidget = G3MWidget::create(getGL(), getStorage(), getDownloader(), getThreadUtils(), cameraActivityListener, planet, *cameraConstraints, createCameraRenderer(), mainRenderer, createBusyRenderer(), createErrorRenderer(), hudRenderer, Color::black(), false, false, initializationTask, true, *periodicalTasks, getGPUProgramManager(), createSceneLighting(), icpp, infoDisplay, MONO); delete cameraConstraints; delete periodicalTasks; return _g3mWidget; } int MapBooOLDBuilder::getApplicationEventId() const { return _applicationEventId; } void MapBooOLDBuilder::setApplicationEventId(const int eventId) { _applicationEventId = eventId; } int MapBooOLDBuilder::getApplicationTimestamp() const { return _applicationTimestamp; } const std::string MapBooOLDBuilder::getApplicationId() { return _applicationId; } void MapBooOLDBuilder::saveApplicationData() const { } void MapBooOLDBuilder::setHasParsedApplication() { _hasParsedApplication = true; } bool MapBooOLDBuilder::hasParsedApplication() const { return _hasParsedApplication; } void MapBooOLDBuilder::setApplicationTimestamp(const int timestamp) { _applicationTimestamp = timestamp; } void MapBooOLDBuilder::setApplicationName(const std::string& name) { if (_applicationName.compare(name) != 0) { _applicationName = name; if (_applicationListener != NULL) { _applicationListener->onNameChanged(_context, _applicationName); } } } void MapBooOLDBuilder::setApplicationWebsite(const std::string& website) { if (_applicationWebsite.compare(website) != 0) { _applicationWebsite = website; if (_applicationListener != NULL) { _applicationListener->onWebsiteChanged(_context, _applicationWebsite); } } } void MapBooOLDBuilder::setApplicationEMail(const std::string& eMail) { if (_applicationEMail.compare(eMail) != 0) { _applicationEMail = eMail; if (_applicationListener != NULL) { _applicationListener->onEMailChanged(_context, _applicationEMail); } } } void MapBooOLDBuilder::setApplicationAbout(const std::string& about) { if (_applicationAbout.compare(about) != 0) { _applicationAbout = about; if (_applicationListener != NULL) { _applicationListener->onAboutChanged(_context, _applicationAbout); } } } class MapBooOLDBuilder_ChangeSceneTask : public GTask { private: MapBooOLDBuilder* _builder; const std::string _sceneId; public: MapBooOLDBuilder_ChangeSceneTask(MapBooOLDBuilder* builder, const std::string& sceneId) : _builder(builder), _sceneId(sceneId) { } void run(const G3MContext* context) { _builder->rawChangeScene(_sceneId); } }; void MapBooOLDBuilder::rawChangeScene(const std::string& sceneId) { _applicationCurrentSceneId = sceneId; changedCurrentScene(); } void MapBooOLDBuilder::changeScene(const std::string& sceneId) { const std::string currentSceneId = getApplicationCurrentSceneId(); if (currentSceneId.compare(sceneId) != 0) { const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string iSceneId = _applicationScenes[i]->getId(); if (sceneId.compare(iSceneId) == 0) { getThreadUtils()->invokeInRendererThread(new MapBooOLDBuilder_ChangeSceneTask(this, sceneId), true); break; } } } } void MapBooOLDBuilder::changeScene(const MapBooOLD_Scene* scene) { const size_t size = _applicationScenes.size(); for (size_t i = 0; i < size; i++) { if (_applicationScenes[i] == scene) { changeScene(scene->getId()); break; } } } class MapBooOLDBuilder_DummyListener : public IBufferDownloadListener { public: MapBooOLDBuilder_DummyListener() { } void onDownload(const URL& url, IByteBuffer* buffer, bool expired) { delete buffer; } void onError(const URL& url) { ILogger::instance()->logError("Can't download %s", url._path.c_str()); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, bool expired) { } }; void MapBooOLDBuilder::changedCurrentScene() { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != NULL) { _g3mWidget->setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget->resetPeriodicalTasksTimeouts(); if (currentScene != NULL) { const Sector* sector = currentScene->getSector(); if (sector == NULL) { _g3mWidget->setRenderedSector( Sector::fullSphere() ); } else { _g3mWidget->setRenderedSector( *sector ); } setCameraPosition(currentScene->getCameraPosition()); } } if (_applicationListener != NULL) { _applicationListener->onCurrentSceneChanged(_context, getApplicationCurrentSceneId(), currentScene); } if (_viewType == VIEW_EDITION_PREVIEW) { if (_applicationCurrentSceneId.compare(_lastApplicationCurrentSceneId) != 0) { if (_lastApplicationCurrentSceneId.compare("-1") != 0) { if (_webSocket != NULL && _isApplicationTubeOpen) { _webSocket->send( getApplicationCurrentSceneCommand() ); } else if (_token.length() > 0) { _g3mWidget->getG3MContext()->getDownloader()->requestBuffer(createApplicationCurrentSceneURL(), DownloadPriority::HIGHEST, TimeInterval::zero(), false, new MapBooOLDBuilder_DummyListener(), false); } else { ILogger::instance()->logError("VIEW_PRESENTATION: can't fire the event of changed scene"); } } _lastApplicationCurrentSceneId = _applicationCurrentSceneId; } } } const std::string MapBooOLDBuilder::getApplicationCurrentSceneCommand() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString("currentSceneId="); isb->addString(_applicationCurrentSceneId); const std::string s = isb->getString(); delete isb; return s; } const URL MapBooOLDBuilder::createApplicationCurrentSceneURL() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString(_serverURL._path); isb->addString("/REST/1/applications/"); isb->addString(_applicationId); isb->addString("/_POST_?"); isb->addString("currentSceneId="); isb->addString(_applicationCurrentSceneId); isb->addString("&token="); isb->addString(_token); const std::string path = isb->getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder::updateVisibleScene(const bool cameraPositionChanged) { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != NULL) { _g3mWidget->setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget->resetPeriodicalTasksTimeouts(); if (currentScene != NULL) { const Sector* sector = currentScene->getSector(); if (sector == NULL) { _g3mWidget->setRenderedSector( Sector::fullSphere() ); } else { _g3mWidget->setRenderedSector( *sector ); } if (cameraPositionChanged) { setCameraPosition(currentScene->getCameraPosition()); } } } } void MapBooOLDBuilder::setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition, const bool animated) { if (cameraPosition != NULL) { if (animated) { _g3mWidget->setAnimatedCameraPosition(TimeInterval::fromSeconds(3), cameraPosition->getPosition(), cameraPosition->getHeading(), cameraPosition->getPitch()); } else { _g3mWidget->setCameraPosition( cameraPosition->getPosition() ); _g3mWidget->setCameraHeading( cameraPosition->getHeading() ); _g3mWidget->setCameraPitch( cameraPosition->getPitch() ); } } } void MapBooOLDBuilder::setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition) { if (cameraPosition != NULL) { const bool animated = cameraPosition->isAnimated(); setCameraPosition(cameraPosition, animated); } } void MapBooOLDBuilder::fireOnScenesChanged() { if (_applicationListener != NULL) { } } void MapBooOLDBuilder::addApplicationScene(MapBooOLD_Scene* scene, const int position) { fireOnScenesChanged(); } void MapBooOLDBuilder::deleteApplicationScene(const std::string &sceneId) { const int scenesCount = _applicationScenes.size(); int sceneIndex = -1; for (int i = 0; i < scenesCount; i++) { const std::string iSceneId = _applicationScenes[i]->getId(); if (iSceneId.compare(sceneId) == 0) { sceneIndex = i; break; } } if (sceneIndex != -1) { MapBooOLD_Scene* scene = _applicationScenes[sceneIndex];_applicationScenes.remove(sceneIndex);

<<<<<<< HEAD bool MapBooBuilder::onTerrainTouch(const G3MEventContext* ec, ======= bool MapBooOLDBuilder::onTerrainTouch(const G3MEventContext* ec, >>>>>>> 882166c33bdf9946c54ea507ad5e1c47fb3e83e0 const Vector2F& pixel, const Camera* camera, const Geodetic3D& position, const Tile* tile) { if (_applicationListener != NULL) { _applicationListener->onTerrainTouch(this, ec, pixel, camera, position, tile); } return true; } PlanetRenderer* MapBooOLDBuilder::createPlanetRenderer() { const bool skirted = true; TileTessellator* tessellator = new PlanetTileTessellator(skirted, Sector::fullSphere()); ElevationDataProvider* elevationDataProvider = NULL; const float verticalExaggeration = 1; TileTexturizer* texturizer = new DefaultTileTexturizer(new DownloaderImageBuilder(URL("http://www.mapboo.com/web/img/tileNotFound.jpg"))); const bool renderDebug = false; const bool forceFirstLevelTilesRenderOnStart = true; const bool incrementalTileQuality = false; const Quality quality = QUALITY_LOW; const TilesRenderParameters* parameters = new TilesRenderParameters(renderDebug, forceFirstLevelTilesRenderOnStart, incrementalTileQuality, quality); const bool showStatistics = false; long long tileDownloadPriority = DownloadPriority::HIGHER; const Sector renderedSector = Sector::fullSphere(); const bool renderTileMeshes = true; const bool logTilesPetitions = false; ChangedRendererInfoListener* changedRendererInfoListener = NULL; TouchEventType touchEventTypeOfTerrainTouchListener = DownUp; PlanetRenderer* result = new PlanetRenderer(tessellator, elevationDataProvider, true, verticalExaggeration, texturizer, _layerSet, parameters, showStatistics, tileDownloadPriority, renderedSector, renderTileMeshes, logTilesPetitions, changedRendererInfoListener, touchEventTypeOfTerrainTouchListener, getTileLODTester(), getTileVisibilityTester()); if (_enableNotifications) { result->addTerrainTouchListener(new MapBooOLDBuilder_TerrainTouchListener(this)); } return result; } const Planet* MapBooOLDBuilder::createPlanet() { return SphericalPlanet::createEarth(); } std::vector<ICameraConstrainer*>* MapBooOLDBuilder::createCameraConstraints(const Planet* planet, PlanetRenderer* planetRenderer) { std::vector<ICameraConstrainer*>* cameraConstraints = new std::vector<ICameraConstrainer*>; const Geodetic3D initialCameraPosition = planet->getDefaultCameraPosition(Sector::fullSphere()); cameraConstraints->push_back( new RenderedSectorCameraConstrainer(planetRenderer, initialCameraPosition._height * 1.2) ); return cameraConstraints; } CameraRenderer* MapBooOLDBuilder::createCameraRenderer() { CameraRenderer* cameraRenderer = new CameraRenderer(); const bool useInertia = true; cameraRenderer->addHandler(new CameraSingleDragHandler(useInertia)); cameraRenderer->addHandler(new CameraDoubleDragHandler()); cameraRenderer->addHandler(new CameraRotationHandler()); return cameraRenderer; } ProtoRenderer* MapBooOLDBuilder::createBusyRenderer() { return new BusyMeshRenderer(Color::newFromRGBA(0, 0, 0, 1)); } class Mapboo_ErrorMessagesCustomizer : public ErrorMessagesCustomizer { private: MapBooOLDBuilder* _mbBuilder; public: Mapboo_ErrorMessagesCustomizer(MapBooOLDBuilder* mbBuilder) { _mbBuilder = mbBuilder; } ~Mapboo_ErrorMessagesCustomizer() {} std::vector<std::string> customize(const std::vector<std::string>& errors) { std::vector<std::string> customizedErrorMessages; const IStringUtils* stringUtils = IStringUtils::instance(); const size_t errorsSize = errors.size(); const std::string appNotFound = "Invalid request: Application #" + _mbBuilder->getApplicationId() + " not found"; for (size_t i = 0; i < errorsSize; i++) { std::string error = errors.at(i); if (stringUtils->beginsWith(error, appNotFound)) { customizedErrorMessages.push_back("Oops, application not found!"); break; } customizedErrorMessages.push_back(error); } return customizedErrorMessages; } }; ErrorRenderer* MapBooOLDBuilder::createErrorRenderer() { return new HUDErrorRenderer(new Mapboo_ErrorMessagesCustomizer(this)); } MapQuestLayer* MapBooOLDBuilder::parseMapQuestLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string imagery = jsonLayer->getAsString("imagery", "<imagery not present>"); if (imagery.compare("OpenAerial") == 0) { return MapQuestLayer::newOpenAerial(timeToCache); } return MapQuestLayer::newOSM(timeToCache); } BingMapsLayer* MapBooOLDBuilder::parseBingMapsLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string key = jsonLayer->getAsString("key", ""); const std::string imagerySet = jsonLayer->getAsString("imagerySet", "Aerial"); return new BingMapsLayer(imagerySet, key, timeToCache, true, 2, 25, 1, NULL, new std::vector<const Info*>()); } CartoDBLayer* MapBooOLDBuilder::parseCartoDBLayer(const JSONObject* jsonLayer, const bool transparent, const TimeInterval& timeToCache) const { const std::string userName = jsonLayer->getAsString("userName", ""); const std::string table = jsonLayer->getAsString("table", ""); return new CartoDBLayer(userName, table, timeToCache, true, 1, transparent, NULL, new std::vector<const Info*>()); } MapBoxLayer* MapBooOLDBuilder::parseMapBoxLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string mapKey = jsonLayer->getAsString("mapKey", ""); return new MapBoxLayer(mapKey, timeToCache, true, 1, 19, 1, NULL, new std::vector<const Info*>()); } WMSLayer* MapBooOLDBuilder::parseWMSLayer(const JSONObject* jsonLayer, const bool transparent) const { const std::string mapLayer = jsonLayer->getAsString("layerName", ""); const URL mapServerURL = URL(jsonLayer->getAsString("server", ""), false); const std::string versionStr = jsonLayer->getAsString("version", ""); WMSServerVersion mapServerVersion = WMS_1_1_0; if (versionStr.compare("WMS_1_3_0") == 0) { mapServerVersion = WMS_1_3_0; } const std::string queryLayer = jsonLayer->getAsString("queryLayer", ""); const std::string style = jsonLayer->getAsString("style", ""); const URL queryServerURL = URL("", false); const WMSServerVersion queryServerVersion = mapServerVersion; const Sector sector = parseSector(jsonLayer, "validSector"); std::string imageFormat = jsonLayer->getAsString("imageFormat", "image/png"); const std::string srs = jsonLayer->getAsString("projection", "EPSG:4326"); LayerTilesRenderParameters* layerTilesRenderParameters = NULL; if (srs.compare("EPSG:4326") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters::createDefaultWGS84(0, 17); } else if (srs.compare("EPSG:3857") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters::createDefaultMercator(0, 17); } const double expiration = jsonLayer->getAsNumber("expiration", 0); const long long milliseconds = IMathUtils::instance()->round(expiration); const TimeInterval timeToCache = TimeInterval::fromMilliseconds(milliseconds); const bool readExpired = jsonLayer->getAsBoolean("acceptExpiration", false); return new WMSLayer(mapLayer, mapServerURL, mapServerVersion, queryLayer, queryServerURL, queryServerVersion, sector, imageFormat, srs, style, transparent, NULL, timeToCache, readExpired, layerTilesRenderParameters); } URLTemplateLayer* MapBooOLDBuilder::parseURLTemplateLayer(const JSONObject* jsonLayer, const bool transparent) const { const std::string urlTemplate = jsonLayer->getAsString("url", ""); const int firstLevel = (int) jsonLayer->getAsNumber("firstLevel", 1); const int maxLevel = (int) jsonLayer->getAsNumber("maxLevel", 19); const std::string projection = jsonLayer->getAsString("projection", "EPSG:3857"); const bool mercator = (projection == "EPSG:3857"); const Sector sector = parseSector(jsonLayer, "validSector"); URLTemplateLayer* result; if (mercator) { result = URLTemplateLayer::newMercator(urlTemplate, sector, transparent, firstLevel, maxLevel, TimeInterval::fromDays(30)); } else { result = new URLTemplateLayer(urlTemplate, sector, transparent, TimeInterval::fromDays(30), true, new LevelTileCondition(firstLevel, maxLevel), LayerTilesRenderParameters::createDefaultWGS84(sector, 1, maxLevel)); } return result; } Layer* MapBooOLDBuilder::parseLayer(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == NULL) { return NULL; } if (jsonBaseObjectLayer->asNull() != NULL) { return NULL; } const TimeInterval defaultTimeToCache = TimeInterval::fromDays(30); const JSONObject* jsonLayer = jsonBaseObjectLayer->asObject(); if (jsonLayer == NULL) { ILogger::instance()->logError("Layer is not a json object"); return NULL; } const bool transparent = jsonLayer->getAsBoolean("transparent", false); const std::string layerType = jsonLayer->getAsString("layer", "<layer not present>"); Layer* layer; if (layerType.compare("OSM") == 0) { layer = new OSMLayer(defaultTimeToCache, true, 2, 1, NULL, new std::vector<const Info*>()); } else if (layerType.compare("MapQuest") == 0) { layer = parseMapQuestLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("BingMaps") == 0) { layer = parseBingMapsLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("CartoDB") == 0) { layer = parseCartoDBLayer(jsonLayer, transparent, defaultTimeToCache); } else if (layerType.compare("MapBox") == 0) { layer = parseMapBoxLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("WMS") == 0) { layer = parseWMSLayer(jsonLayer, transparent); } else if (layerType.compare("URLTemplate") == 0) { layer = parseURLTemplateLayer(jsonLayer, transparent); } else { ILogger::instance()->logError("Unsupported layer type \"%s\"", layerType.c_str()); ILogger::instance()->logError("%s", jsonBaseObjectLayer->description().c_str()); return NULL; } const std::string layerAttribution = jsonLayer->getAsString("attribution", ""); if (layerAttribution.compare("") != 0) { layer->addInfo(new Info(layerAttribution)); } return layer; } Color MapBooOLDBuilder::parseColor(const JSONString* jsonColor) const { if (jsonColor == NULL) { return Color::black(); } const Color* color = Color::parse(jsonColor->value()); if (color == NULL) { ILogger::instance()->logError("Invalid format in attribute 'color' (%s)", jsonColor->value().c_str()); return Color::black(); } Color result(*color); delete color; return result; } MapBooOLD_MultiImage_Level* MapBooOLDBuilder::parseMultiImageLevel(const JSONObject* jsonObject) const { const JSONString* jsURL = jsonObject->getAsString("url"); if (jsURL == NULL) { return NULL; } const JSONNumber* jsWidth = jsonObject->getAsNumber("width"); if (jsWidth == NULL) { return NULL; } const JSONNumber* jsHeight = jsonObject->getAsNumber("height"); if (jsHeight == NULL) { return NULL; } return new MapBooOLD_MultiImage_Level(URL(_serverURL, "/images/" + jsURL->value()), (int) jsWidth->value(), (int) jsHeight->value()); } MapBooOLD_MultiImage* MapBooOLDBuilder::parseMultiImage(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } Color averageColor = parseColor( jsonObject->getAsString("averageColor") ); std::vector<MapBooOLD_MultiImage_Level*> levels; const JSONArray* jsLevels = jsonObject->getAsArray("levels"); if (jsLevels != NULL) { const size_t levelsCount = jsLevels->size(); for (size_t i = 0; i < levelsCount; i++) { MapBooOLD_MultiImage_Level* level = parseMultiImageLevel( jsLevels->getAsObject(i) ); if (level != NULL) { levels.push_back(level); } } } return new MapBooOLD_MultiImage(averageColor, levels); } const MapBooOLD_CameraPosition* MapBooOLDBuilder::parseCameraPosition(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } const double latitudeInDegress = jsonObject->getAsNumber("latitude", 0); const double longitudeInDegress = jsonObject->getAsNumber("longitude", 0); const double height = jsonObject->getAsNumber("height", 0); const double headingInDegrees = jsonObject->getAsNumber("heading", 0); const double pitchInDegrees = jsonObject->getAsNumber("pitch", 0); const bool animated = jsonObject->getAsBoolean("animated", true); return new MapBooOLD_CameraPosition(Geodetic3D::fromDegrees(latitudeInDegress, longitudeInDegress, height), Angle::fromDegrees(headingInDegrees), Angle::fromDegrees(pitchInDegrees), animated); } Sector* MapBooOLDBuilder::parseSector(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == NULL) { return NULL; } if (jsonBaseObjectLayer->asNull() != NULL) { return NULL; } const JSONObject* jsonObject = jsonBaseObjectLayer->asObject(); if (jsonObject == NULL) { return NULL; } const double lowerLat = jsonObject->getAsNumber("lowerLat", -90.0); const double lowerLon = jsonObject->getAsNumber("lowerLon", -180.0); const double upperLat = jsonObject->getAsNumber("upperLat", 90.0); const double upperLon = jsonObject->getAsNumber("upperLon", 180.0); return new Sector(Geodetic2D::fromDegrees(lowerLat, lowerLon), Geodetic2D::fromDegrees(upperLat, upperLon)); } const Sector MapBooOLDBuilder::parseSector(const JSONObject* jsonObject, const std::string& paramName) const { const JSONObject* sector = jsonObject->getAsObject(paramName); if (sector == NULL) { return Sector::fullSphere(); } if (sector->asNull() != NULL) { return Sector::fullSphere(); } const double lowerLat = sector->getAsNumber("lowerLat", -90.0); const double lowerLon = sector->getAsNumber("lowerLon", -180.0); const double upperLat = sector->getAsNumber("upperLat", 90.0); const double upperLon = sector->getAsNumber("upperLon", 180.0); return Sector(Geodetic2D::fromDegrees(lowerLat, lowerLon), Geodetic2D::fromDegrees(upperLat, upperLon)); } MapBooOLD_Scene* MapBooOLDBuilder::parseScene(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } const bool hasWarnings = jsonObject->getAsBoolean("hasWarnings", false); const bool queryable = jsonObject->getAsBoolean("queryable", false); return new MapBooOLD_Scene(jsonObject->getAsString("id", ""), jsonObject->getAsString("name", ""), jsonObject->getAsString("description", ""), parseMultiImage( jsonObject->getAsObject("screenshot") ), parseColor( jsonObject->getAsString("backgroundColor") ), parseCameraPosition( jsonObject->getAsObject("cameraPosition") ), parseSector( jsonObject->get("sector") ), parseLayer( jsonObject->get("baseLayer") ), parseLayer( jsonObject->get("overlayLayer") ), queryable, hasWarnings); } const URL* MapBooOLDBuilder::parseURL(const JSONString* jsonString) const { if (jsonString == NULL) { return NULL; } return new URL(jsonString->value()); } MapBooOLD_Notification* MapBooOLDBuilder::parseNotification(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } return new MapBooOLD_Notification(Geodetic2D::fromDegrees(jsonObject->getAsNumber("latitude", 0), jsonObject->getAsNumber("longitude", 0)), parseCameraPosition( jsonObject->getAsObject("cameraPosition") ), jsonObject->getAsString("message", ""), parseURL( jsonObject->getAsString("iconURL") ) ); } std::vector<MapBooOLD_Notification*>* MapBooOLDBuilder::parseNotifications(const JSONArray* jsonArray) const { std::vector<MapBooOLD_Notification*>* result = new std::vector<MapBooOLD_Notification*>(); if (jsonArray != NULL) { const size_t size = jsonArray->size(); for (size_t i = 0; i < size; i++) { MapBooOLD_Notification* notification = parseNotification( jsonArray->getAsObject(i) ); if (notification != NULL) { result->push_back(notification); } } } return result; } void MapBooOLDBuilder::parseApplicationEventsJSON(const std::string& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser::instance()->parse(json, true); if (jsonBaseObject == NULL) { ILogger::instance()->logError("Can't parse ApplicationJSON from %s", url._path.c_str()); } else { const JSONArray* jsonArray = jsonBaseObject->asArray(); if (jsonArray != NULL) { const size_t size = jsonArray->size(); for (size_t i = 0; i < size; i++) { const JSONObject* jsonObject = jsonArray->getAsObject(i); parseApplicationJSON(jsonObject, url); } } else { parseApplicationJSON(json, url); } } delete jsonBaseObject; } void MapBooOLDBuilder::parseApplicationJSON(const JSONObject* jsonObject, const URL& url) { std::vector<std::string> errors; if (jsonObject == NULL) { ILogger::instance()->logError("Invalid ApplicationJSON"); } else { const JSONString* jsonError = jsonObject->getAsString("error"); if (jsonError == NULL) { const int eventId = (int) jsonObject->getAsNumber("eventId", 0); const int timestamp = (int) jsonObject->getAsNumber("timestamp", 0); if (getApplicationEventId() != eventId) { const JSONString* jsonName = jsonObject->getAsString("name"); if (jsonName != NULL) { setApplicationName( jsonName->value() ); } const JSONString* jsonWebsite = jsonObject->getAsString("website"); if (jsonWebsite != NULL) { setApplicationWebsite( jsonWebsite->value() ); } const JSONString* jsonEMail = jsonObject->getAsString("email"); if (jsonEMail != NULL) { setApplicationEMail( jsonEMail->value() ); } const JSONString* jsonAbout = jsonObject->getAsString("about"); if (jsonAbout != NULL) { setApplicationAbout( jsonAbout->value() ); } const JSONObject* jsonScene = jsonObject->getAsObject("scene"); if (jsonScene != NULL) { parseSceneEventAndUpdateScene(jsonScene); } const JSONArray* jsonAllScenes = jsonObject->getAsArray("scenes"); if (jsonAllScenes != NULL) { std::vector<MapBooOLD_Scene*> scenes; const size_t scenesCount = jsonAllScenes->size(); for (size_t i = 0; i < scenesCount; i++) { MapBooOLD_Scene* scene = parseScene( jsonAllScenes->getAsObject(i) ); if (scene != NULL) { scenes.push_back(scene); } } setApplicationScenes(scenes); } const JSONObject* jsonScenes = jsonObject->getAsObject("scenes"); if (jsonScenes != NULL) { const JSONObject* jsonPutScene = jsonScenes->getAsObject("putScene"); if (jsonPutScene != NULL) { const JSONNumber* jsonPosition = jsonPutScene->getAsNumber("position"); int position = (jsonPosition != NULL) ? (int) jsonPosition->value() : 0; const JSONObject* jsonNewScene = jsonPutScene->getAsObject("scene"); if (jsonNewScene != NULL) { MapBooOLD_Scene* scene = parseScene(jsonNewScene); if (scene != NULL) { addApplicationScene(scene, position); } } } else { const JSONObject* jsonDeleteScene = jsonScenes->getAsObject("deleteScene"); if (jsonDeleteScene != NULL) { const JSONString* jsonSceneId = jsonDeleteScene->getAsString("sceneId"); if (jsonSceneId != NULL) { deleteApplicationScene(jsonSceneId->value()); } } } } setApplicationEventId(eventId); setApplicationTimestamp(timestamp); saveApplicationData(); setHasParsedApplication(); } const JSONString* jsonCurrentSceneId = jsonObject->getAsString("currentSceneId"); if (jsonCurrentSceneId != NULL) { setApplicationCurrentSceneId( jsonCurrentSceneId->value() ); } if (_enableNotifications) { const JSONArray* jsonNotifications = jsonObject->getAsArray("notifications"); if (jsonNotifications != NULL) { addApplicationNotifications( parseNotifications(jsonNotifications) ); } const JSONObject* jsonNotification = jsonObject->getAsObject("notification"); if (jsonNotification != NULL) { addApplicationNotification( parseNotification(jsonNotification) ); } } if (_initialParse) { _initialParse = false; if (_applicationCurrentSceneId.compare("-1") == 0) { if (_applicationScenes.size() > 0) { setApplicationCurrentSceneId(_applicationScenes.at(0)->getId()); } } } } else { errors.push_back(jsonError->value().c_str()); ILogger::instance()->logError("Server Error: %s", jsonError->value().c_str()); if (_initialParse) { _initialParse = false; setHasParsedApplication(); } } } _mbErrorRenderer->setErrors(errors); } void MapBooOLDBuilder::parseApplicationJSON(const std::string& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser::instance()->parse(json, true); if (jsonBaseObject == NULL) { ILogger::instance()->logError("Can't parse ApplicationJSON from %s", url._path.c_str()); } else { const JSONObject* jsonObject = jsonBaseObject->asObject(); parseApplicationJSON(jsonObject, url); } delete jsonBaseObject; } void MapBooOLDBuilder::parseSceneEventAndUpdateScene(const JSONObject* jsonObject) { if (jsonObject == NULL) { return; } const JSONString* jsonSceneToBeUpdatedID = jsonObject->getAsString("id"); if (jsonSceneToBeUpdatedID == NULL) { return; } const std::string sceneToBeUpdatedID = jsonSceneToBeUpdatedID->value(); const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneID = _applicationScenes[i]->getId(); if (sceneID.compare(sceneToBeUpdatedID) == 0) { MapBooOLD_Scene* oldScene = _applicationScenes[i]; const std::string name = jsonObject->getAsString("name", oldScene->getName()); const std::string description = jsonObject->getAsString("description", oldScene->getDescription()); const JSONBaseObject* jboScreenshot = jsonObject->get("screenshot"); const MapBooOLD_MultiImage* screenshot; if (jboScreenshot != NULL) { screenshot = parseMultiImage(jboScreenshot->asObject()); } else { const MapBooOLD_MultiImage* oldScreenshot = oldScene->getScreenshot(); screenshot = (oldScreenshot != NULL) ? oldScreenshot->deepCopy() : NULL; } const JSONBaseObject* jboBackgroundColor = jsonObject->get("backgroundColor"); const Color backgroundColor = (jboBackgroundColor != NULL) ? parseColor(jboBackgroundColor->asString()) : oldScene->getBackgroundColor(); const JSONBaseObject* jboCameraPosition = jsonObject->get("cameraPosition"); const MapBooOLD_CameraPosition* cameraPosition; if (jboCameraPosition != NULL) { cameraPosition = parseCameraPosition(jboCameraPosition->asObject()); } else { const MapBooOLD_CameraPosition* oldCameraPosition = oldScene->getCameraPosition(); cameraPosition = (oldCameraPosition != NULL) ? new MapBooOLD_CameraPosition(oldCameraPosition->getPosition(), oldCameraPosition->getHeading(), oldCameraPosition->getPitch(), oldCameraPosition->isAnimated()) : NULL ; } const JSONBaseObject* jboSector = jsonObject->get("sector"); const Sector* sector; if (jboSector != NULL) { sector = parseSector(jboSector->asObject()); } else { const Sector* oldSector = oldScene->getSector(); sector = (oldSector != NULL) ? new Sector(oldSector->_lower, oldSector->_upper) : NULL; } const JSONBaseObject* jboBaseLayer = jsonObject->get("baseLayer"); Layer* baseLayer = (jboBaseLayer != NULL) ? parseLayer(jboBaseLayer->asObject()) : oldScene->getBaseLayer()->copy(); const JSONBaseObject* jboOverlayLayer = jsonObject->get("overlayLayer"); Layer* oldOverlayLayer = (oldScene->getOverlayLayer() != NULL) ? oldScene->getOverlayLayer()->copy() : NULL; Layer* overlayLayer = (jboOverlayLayer != NULL) ? parseLayer(jboOverlayLayer->asObject()) : oldOverlayLayer; const bool hasWarnings = jsonObject->getAsBoolean("hasWarnings", false); const bool queryable = jsonObject->getAsBoolean("queryable", oldScene->isQueryable()); const bool cameraPositionChaged = (jboCameraPosition != NULL); MapBooOLD_Scene* newScene = new MapBooOLD_Scene(sceneToBeUpdatedID, name, description, screenshot, backgroundColor, cameraPosition, sector, baseLayer, overlayLayer, queryable, hasWarnings); _applicationScenes[i] = newScene; if (sceneID.compare(_applicationCurrentSceneId) == 0) { updateVisibleScene(cameraPositionChaged); } if (_applicationListener != NULL) { _applicationListener->onSceneChanged(_context, newScene); } fireOnScenesChanged(); delete oldScene; break; } } } void MapBooOLDBuilder::addApplicationNotifications(const std::vector<MapBooOLD_Notification*>* notifications) { if (notifications == NULL) { return; } const size_t size = notifications->size(); for (size_t i = 0; i < size; i++) { MapBooOLD_Notification* notification = notifications->at(i); if (notification != NULL) { addApplicationNotification(notification); } } delete notifications; } void MapBooOLDBuilder::addApplicationNotification(MapBooOLD_Notification* notification) { if (_marksRenderer != NULL) { const std::string message = notification->getMessage(); const bool hasMessage = (message.size() > 0); const URL* iconURL = notification->getIconURL(); const Geodetic2D position = notification->getPosition(); bool newMark = false; if (hasMessage) { if (iconURL == NULL) { _marksRenderer->addMark( new Mark(message, Geodetic3D(position, 0), ABSOLUTE, 0) ); } else { _marksRenderer->addMark( new Mark(message, *iconURL, Geodetic3D(position, 0), ABSOLUTE, 0) ); } newMark = true; } else { if (iconURL != NULL) { _marksRenderer->addMark( new Mark(*iconURL, Geodetic3D(position, 0), ABSOLUTE, 0) ); newMark = true; } } if (newMark) { const MapBooOLD_CameraPosition* cameraPosition = notification->getCameraPosition(); if (cameraPosition != NULL) { setCameraPosition(cameraPosition, true); } } } delete notification; } void MapBooOLDBuilder::setApplicationCurrentSceneId(const std::string& currentSceneId) { if (_applicationCurrentSceneId.compare(currentSceneId) != 0) { const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneId = _applicationScenes[i]->getId(); if (sceneId.compare(currentSceneId) == 0) { _applicationCurrentSceneId = currentSceneId; changedCurrentScene(); break; } } } } LayerSet* MapBooOLD_Scene::createLayerSet() const { LayerSet* layerSet = new LayerSet(); if (_baseLayer != NULL) { layerSet->addLayer(_baseLayer->copy()); } if (_overlayLayer != NULL) { layerSet->addLayer(_overlayLayer->copy()); } return layerSet; } void MapBooOLDBuilder::recreateLayerSet() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); if (scene == NULL) { _layerSet->removeAllLayers(true); } else { LayerSet* newLayerSet = scene->createLayerSet(); if (!newLayerSet->isEquals(_layerSet)) { _layerSet->removeAllLayers(true); _layerSet->takeLayersFrom(newLayerSet); } delete newLayerSet; } } const URL MapBooOLDBuilder::createApplicationTubeURL() const { const std::string tubesPath = _tubesURL._path; std::string view; switch (_viewType) { case VIEW_PRESENTATION: view = "presentation"; break; case VIEW_EDITION_PREVIEW: view = "edition-preview"; break; default: view = "runtime"; } return URL(tubesPath + "/application/" + _applicationId + "/" + view, false); } class MapBooOLDBuilder_TubeWatchdogPeriodicalTask : public GTask { private: MapBooOLDBuilder* _builder; bool _firstRun; public: MapBooOLDBuilder_TubeWatchdogPeriodicalTask(MapBooOLDBuilder* builder) : _builder(builder), _firstRun(true) { } void run(const G3MContext* context) { if (_firstRun) { _firstRun = false; } else { if (!_builder->isApplicationTubeOpen()) { _builder->pollApplicationDataFromServer(context); _builder->openApplicationTube(context); } } } }; std::vector<PeriodicalTask*>* MapBooOLDBuilder::createPeriodicalTasks() { std::vector<PeriodicalTask*>* periodicalTasks = new std::vector<PeriodicalTask*>(); periodicalTasks->push_back(new PeriodicalTask(TimeInterval::fromSeconds(5), new MapBooOLDBuilder_TubeWatchdogPeriodicalTask(this))); return periodicalTasks; } IStorage* MapBooOLDBuilder::getStorage() { if (_storage == NULL) { _storage = createStorage(); } return _storage; } class MapBooOLDBuilder_ApplicationTubeListener : public IWebSocketListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeListener(MapBooOLDBuilder* builder) : _builder(builder) { } ~MapBooOLDBuilder_ApplicationTubeListener() { } void onOpen(IWebSocket* ws) { ILogger::instance()->logInfo("Tube '%s' opened!", ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(true); } void onError(IWebSocket* ws, const std::string& error) { ILogger::instance()->logError("Error '%s' on Tube '%s'", error.c_str(), ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(false); } void onMessage(IWebSocket* ws, const std::string& message) { _builder->parseApplicationJSON(message, ws->getURL()); } void onClose(IWebSocket* ws) { ILogger::instance()->logError("Tube '%s' closed!", ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(false); } }; class MapBooOLDBuilder_ApplicationTubeConnector : public GInitializationTask { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeConnector(MapBooOLDBuilder* builder) : _builder(builder) { } void run(const G3MContext* context) { _builder->setContext(context); _builder->openApplicationTube(context); } bool isDone(const G3MContext* context) { return _builder->hasParsedApplication(); } }; void MapBooOLDBuilder::setContext(const G3MContext* context) { _context = context; } MapBooOLDBuilder::~MapBooOLDBuilder() { } class MapBooOLDBuilder_RestJSON : public IBufferDownloadListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_RestJSON(MapBooOLDBuilder* builder) : _builder(builder) { } void onDownload(const URL& url, IByteBuffer* buffer, bool expired) { _builder->parseApplicationEventsJSON(buffer->getAsString(), url); delete buffer; } void onError(const URL& url) { ILogger::instance()->logError("Can't download %s", url._path.c_str()); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, bool expired) { } }; const URL MapBooOLDBuilder::createApplicationPollURL() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString(_serverURL._path); isb->addString("/poll/"); isb->addString(_applicationId); isb->addString("?view="); isb->addString(getViewAsString()); isb->addString("&eventId="); isb->addInt(_applicationEventId); const std::string path = isb->getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder::openApplicationTube(const G3MContext* context) { const IFactory* factory = context->getFactory(); _webSocket = factory->createWebSocket(createApplicationTubeURL(), new MapBooOLDBuilder_ApplicationTubeListener(this), true , true ); } const std::string MapBooOLDBuilder::getApplicationCurrentSceneId() { return _applicationCurrentSceneId; } const MapBooOLD_Scene* MapBooOLDBuilder::getApplicationCurrentScene() { const std::string currentSceneId = getApplicationCurrentSceneId(); const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneId = _applicationScenes[i]->getId(); if (sceneId.compare(currentSceneId) == 0) { return _applicationScenes[i]; } } return NULL; } Color MapBooOLDBuilder::getCurrentBackgroundColor() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); return (scene == NULL) ? Color::black() : scene->getBackgroundColor(); } MarksRenderer* MapBooOLDBuilder::getMarksRenderer() { if (_marksRenderer == NULL) { _marksRenderer = new MarksRenderer(false); } return _marksRenderer; } G3MWidget* MapBooOLDBuilder::create() { if (_g3mWidget != NULL) { ILogger::instance()->logError("The G3MWidget was already created, can't be created more than once"); return NULL; } CompositeRenderer* mainRenderer = new CompositeRenderer(); _mbErrorRenderer = new MapBooOLD_ErrorRenderer(); mainRenderer->addRenderer(_mbErrorRenderer); const Planet* planet = createPlanet(); PlanetRenderer* planetRenderer = createPlanetRenderer(); mainRenderer->addRenderer(planetRenderer); mainRenderer->addRenderer(getMarksRenderer()); std::vector<ICameraConstrainer*>* cameraConstraints = createCameraConstraints(planet, planetRenderer); GInitializationTask* initializationTask = new MapBooOLDBuilder_ApplicationTubeConnector(this); std::vector<PeriodicalTask*>* periodicalTasks = createPeriodicalTasks(); ICameraActivityListener* cameraActivityListener = NULL; InitialCameraPositionProvider* icpp = new SimpleInitialCameraPositionProvider(); MapBooOLD_HUDRenderer* hudRenderer = new MapBooOLD_HUDRenderer(); InfoDisplay* infoDisplay = new MapBooOLD_HUDRendererInfoDisplay(hudRenderer); infoDisplay->showDisplay(); _g3mWidget = G3MWidget::create(getGL(), getStorage(), getDownloader(), getThreadUtils(), cameraActivityListener, planet, *cameraConstraints, createCameraRenderer(), mainRenderer, createBusyRenderer(), createErrorRenderer(), hudRenderer, Color::black(), false, false, initializationTask, true, *periodicalTasks, getGPUProgramManager(), createSceneLighting(), icpp, infoDisplay, MONO); delete cameraConstraints; delete periodicalTasks; return _g3mWidget; } int MapBooOLDBuilder::getApplicationEventId() const { return _applicationEventId; } void MapBooOLDBuilder::setApplicationEventId(const int eventId) { _applicationEventId = eventId; } int MapBooOLDBuilder::getApplicationTimestamp() const { return _applicationTimestamp; } const std::string MapBooOLDBuilder::getApplicationId() { return _applicationId; } void MapBooOLDBuilder::saveApplicationData() const { } void MapBooOLDBuilder::setHasParsedApplication() { _hasParsedApplication = true; } bool MapBooOLDBuilder::hasParsedApplication() const { return _hasParsedApplication; } void MapBooOLDBuilder::setApplicationTimestamp(const int timestamp) { _applicationTimestamp = timestamp; } void MapBooOLDBuilder::setApplicationName(const std::string& name) { if (_applicationName.compare(name) != 0) { _applicationName = name; if (_applicationListener != NULL) { _applicationListener->onNameChanged(_context, _applicationName); } } } void MapBooOLDBuilder::setApplicationWebsite(const std::string& website) { if (_applicationWebsite.compare(website) != 0) { _applicationWebsite = website; if (_applicationListener != NULL) { _applicationListener->onWebsiteChanged(_context, _applicationWebsite); } } } void MapBooOLDBuilder::setApplicationEMail(const std::string& eMail) { if (_applicationEMail.compare(eMail) != 0) { _applicationEMail = eMail; if (_applicationListener != NULL) { _applicationListener->onEMailChanged(_context, _applicationEMail); } } } void MapBooOLDBuilder::setApplicationAbout(const std::string& about) { if (_applicationAbout.compare(about) != 0) { _applicationAbout = about; if (_applicationListener != NULL) { _applicationListener->onAboutChanged(_context, _applicationAbout); } } } class MapBooOLDBuilder_ChangeSceneTask : public GTask { private: MapBooOLDBuilder* _builder; const std::string _sceneId; public: MapBooOLDBuilder_ChangeSceneTask(MapBooOLDBuilder* builder, const std::string& sceneId) : _builder(builder), _sceneId(sceneId) { } void run(const G3MContext* context) { _builder->rawChangeScene(_sceneId); } }; void MapBooOLDBuilder::rawChangeScene(const std::string& sceneId) { _applicationCurrentSceneId = sceneId; changedCurrentScene(); } void MapBooOLDBuilder::changeScene(const std::string& sceneId) { const std::string currentSceneId = getApplicationCurrentSceneId(); if (currentSceneId.compare(sceneId) != 0) { const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string iSceneId = _applicationScenes[i]->getId(); if (sceneId.compare(iSceneId) == 0) { getThreadUtils()->invokeInRendererThread(new MapBooOLDBuilder_ChangeSceneTask(this, sceneId), true); break; } } } } void MapBooOLDBuilder::changeScene(const MapBooOLD_Scene* scene) { const size_t size = _applicationScenes.size(); for (size_t i = 0; i < size; i++) { if (_applicationScenes[i] == scene) { changeScene(scene->getId()); break; } } } class MapBooOLDBuilder_DummyListener : public IBufferDownloadListener { public: MapBooOLDBuilder_DummyListener() { } void onDownload(const URL& url, IByteBuffer* buffer, bool expired) { delete buffer; } void onError(const URL& url) { ILogger::instance()->logError("Can't download %s", url._path.c_str()); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, bool expired) { } }; void MapBooOLDBuilder::changedCurrentScene() { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != NULL) { _g3mWidget->setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget->resetPeriodicalTasksTimeouts(); if (currentScene != NULL) { const Sector* sector = currentScene->getSector(); if (sector == NULL) { _g3mWidget->setRenderedSector( Sector::fullSphere() ); } else { _g3mWidget->setRenderedSector( *sector ); } setCameraPosition(currentScene->getCameraPosition()); } } if (_applicationListener != NULL) { _applicationListener->onCurrentSceneChanged(_context, getApplicationCurrentSceneId(), currentScene); } if (_viewType == VIEW_EDITION_PREVIEW) { if (_applicationCurrentSceneId.compare(_lastApplicationCurrentSceneId) != 0) { if (_lastApplicationCurrentSceneId.compare("-1") != 0) { if (_webSocket != NULL && _isApplicationTubeOpen) { _webSocket->send( getApplicationCurrentSceneCommand() ); } else if (_token.length() > 0) { _g3mWidget->getG3MContext()->getDownloader()->requestBuffer(createApplicationCurrentSceneURL(), DownloadPriority::HIGHEST, TimeInterval::zero(), false, new MapBooOLDBuilder_DummyListener(), false); } else { ILogger::instance()->logError("VIEW_PRESENTATION: can't fire the event of changed scene"); } } _lastApplicationCurrentSceneId = _applicationCurrentSceneId; } } } const std::string MapBooOLDBuilder::getApplicationCurrentSceneCommand() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString("currentSceneId="); isb->addString(_applicationCurrentSceneId); const std::string s = isb->getString(); delete isb; return s; } const URL MapBooOLDBuilder::createApplicationCurrentSceneURL() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString(_serverURL._path); isb->addString("/REST/1/applications/"); isb->addString(_applicationId); isb->addString("/_POST_?"); isb->addString("currentSceneId="); isb->addString(_applicationCurrentSceneId); isb->addString("&token="); isb->addString(_token); const std::string path = isb->getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder::updateVisibleScene(const bool cameraPositionChanged) { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != NULL) { _g3mWidget->setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget->resetPeriodicalTasksTimeouts(); if (currentScene != NULL) { const Sector* sector = currentScene->getSector(); if (sector == NULL) { _g3mWidget->setRenderedSector( Sector::fullSphere() ); } else { _g3mWidget->setRenderedSector( *sector ); } if (cameraPositionChanged) { setCameraPosition(currentScene->getCameraPosition()); } } } } void MapBooOLDBuilder::setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition, const bool animated) { if (cameraPosition != NULL) { if (animated) { _g3mWidget->setAnimatedCameraPosition(TimeInterval::fromSeconds(3), cameraPosition->getPosition(), cameraPosition->getHeading(), cameraPosition->getPitch()); } else { _g3mWidget->setCameraPosition( cameraPosition->getPosition() ); _g3mWidget->setCameraHeading( cameraPosition->getHeading() ); _g3mWidget->setCameraPitch( cameraPosition->getPitch() ); } } } void MapBooOLDBuilder::setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition) { if (cameraPosition != NULL) { const bool animated = cameraPosition->isAnimated(); setCameraPosition(cameraPosition, animated); } } void MapBooOLDBuilder::fireOnScenesChanged() { if (_applicationListener != NULL) { } } void MapBooOLDBuilder::addApplicationScene(MapBooOLD_Scene* scene, const int position) { fireOnScenesChanged(); } void MapBooOLDBuilder::deleteApplicationScene(const std::string &sceneId) { const int scenesCount = _applicationScenes.size(); int sceneIndex = -1; for (int i = 0; i < scenesCount; i++) { const std::string iSceneId = _applicationScenes[i]->getId(); if (iSceneId.compare(sceneId) == 0) { sceneIndex = i; break; } } if (sceneIndex != -1) { MapBooOLD_Scene* scene = _applicationScenes[sceneIndex]; delete scene; if (_viewType == VIEW_RUNTIME) { if (_applicationCurrentSceneId.compare(sceneId) == 0) { setApplicationCurrentSceneId(_applicationScenes[0]->getId()); } } fireOnScenesChanged(); } } void MapBooOLDBuilder::setApplicationScenes(const std::vector<MapBooOLD_Scene*>& applicationScenes) { const size_t currentScenesCount = _applicationScenes.size(); for (size_t i = 0; i < currentScenesCount; i++) { MapBooOLD_Scene* scene = _applicationScenes[i]; delete scene; } _applicationScenes.clear();_applicationScenes = new java.util.ArrayList<MapBooOLD_Scene>(applicationScenes);
<<<<<<< HEAD bool MapBooBuilder::onTerrainTouch(const G3MEventContext* ec, ======= bool MapBooOLDBuilder::onTerrainTouch(const G3MEventContext* ec, >>>>>>> 882166c33bdf9946c54ea507ad5e1c47fb3e83e0 const Vector2F& pixel, const Camera* camera, const Geodetic3D& position, const Tile* tile) { if (_applicationListener != NULL) { _applicationListener->onTerrainTouch(this, ec, pixel, camera, position, tile); } return true; } PlanetRenderer* MapBooOLDBuilder::createPlanetRenderer() { const bool skirted = true; TileTessellator* tessellator = new PlanetTileTessellator(skirted, Sector::fullSphere()); ElevationDataProvider* elevationDataProvider = NULL; const float verticalExaggeration = 1; TileTexturizer* texturizer = new DefaultTileTexturizer(new DownloaderImageBuilder(URL("http://www.mapboo.com/web/img/tileNotFound.jpg"))); const bool renderDebug = false; const bool forceFirstLevelTilesRenderOnStart = true; const bool incrementalTileQuality = false; const Quality quality = QUALITY_LOW; const TilesRenderParameters* parameters = new TilesRenderParameters(renderDebug, forceFirstLevelTilesRenderOnStart, incrementalTileQuality, quality); const bool showStatistics = false; long long tileDownloadPriority = DownloadPriority::HIGHER; const Sector renderedSector = Sector::fullSphere(); const bool renderTileMeshes = true; const bool logTilesPetitions = false; ChangedRendererInfoListener* changedRendererInfoListener = NULL; TouchEventType touchEventTypeOfTerrainTouchListener = DownUp; PlanetRenderer* result = new PlanetRenderer(tessellator, elevationDataProvider, true, verticalExaggeration, texturizer, _layerSet, parameters, showStatistics, tileDownloadPriority, renderedSector, renderTileMeshes, logTilesPetitions, changedRendererInfoListener, touchEventTypeOfTerrainTouchListener, getTileLODTester(), getTileVisibilityTester()); if (_enableNotifications) { result->addTerrainTouchListener(new MapBooOLDBuilder_TerrainTouchListener(this)); } return result; } const Planet* MapBooOLDBuilder::createPlanet() { return SphericalPlanet::createEarth(); } std::vector<ICameraConstrainer*>* MapBooOLDBuilder::createCameraConstraints(const Planet* planet, PlanetRenderer* planetRenderer) { std::vector<ICameraConstrainer*>* cameraConstraints = new std::vector<ICameraConstrainer*>; const Geodetic3D initialCameraPosition = planet->getDefaultCameraPosition(Sector::fullSphere()); cameraConstraints->push_back( new RenderedSectorCameraConstrainer(planetRenderer, initialCameraPosition._height * 1.2) ); return cameraConstraints; } CameraRenderer* MapBooOLDBuilder::createCameraRenderer() { CameraRenderer* cameraRenderer = new CameraRenderer(); const bool useInertia = true; cameraRenderer->addHandler(new CameraSingleDragHandler(useInertia)); cameraRenderer->addHandler(new CameraDoubleDragHandler()); cameraRenderer->addHandler(new CameraRotationHandler()); return cameraRenderer; } ProtoRenderer* MapBooOLDBuilder::createBusyRenderer() { return new BusyMeshRenderer(Color::newFromRGBA(0, 0, 0, 1)); } class Mapboo_ErrorMessagesCustomizer : public ErrorMessagesCustomizer { private: MapBooOLDBuilder* _mbBuilder; public: Mapboo_ErrorMessagesCustomizer(MapBooOLDBuilder* mbBuilder) { _mbBuilder = mbBuilder; } ~Mapboo_ErrorMessagesCustomizer() {} std::vector<std::string> customize(const std::vector<std::string>& errors) { std::vector<std::string> customizedErrorMessages; const IStringUtils* stringUtils = IStringUtils::instance(); const size_t errorsSize = errors.size(); const std::string appNotFound = "Invalid request: Application #" + _mbBuilder->getApplicationId() + " not found"; for (size_t i = 0; i < errorsSize; i++) { std::string error = errors.at(i); if (stringUtils->beginsWith(error, appNotFound)) { customizedErrorMessages.push_back("Oops, application not found!"); break; } customizedErrorMessages.push_back(error); } return customizedErrorMessages; } }; ErrorRenderer* MapBooOLDBuilder::createErrorRenderer() { return new HUDErrorRenderer(new Mapboo_ErrorMessagesCustomizer(this)); } MapQuestLayer* MapBooOLDBuilder::parseMapQuestLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string imagery = jsonLayer->getAsString("imagery", "<imagery not present>"); if (imagery.compare("OpenAerial") == 0) { return MapQuestLayer::newOpenAerial(timeToCache); } return MapQuestLayer::newOSM(timeToCache); } BingMapsLayer* MapBooOLDBuilder::parseBingMapsLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string key = jsonLayer->getAsString("key", ""); const std::string imagerySet = jsonLayer->getAsString("imagerySet", "Aerial"); return new BingMapsLayer(imagerySet, key, timeToCache, true, 2, 25, 1, NULL, new std::vector<const Info*>()); } CartoDBLayer* MapBooOLDBuilder::parseCartoDBLayer(const JSONObject* jsonLayer, const bool transparent, const TimeInterval& timeToCache) const { const std::string userName = jsonLayer->getAsString("userName", ""); const std::string table = jsonLayer->getAsString("table", ""); return new CartoDBLayer(userName, table, timeToCache, true, 1, transparent, NULL, new std::vector<const Info*>()); } MapBoxLayer* MapBooOLDBuilder::parseMapBoxLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const std::string mapKey = jsonLayer->getAsString("mapKey", ""); return new MapBoxLayer(mapKey, timeToCache, true, 1, 19, 1, NULL, new std::vector<const Info*>()); } WMSLayer* MapBooOLDBuilder::parseWMSLayer(const JSONObject* jsonLayer, const bool transparent) const { const std::string mapLayer = jsonLayer->getAsString("layerName", ""); const URL mapServerURL = URL(jsonLayer->getAsString("server", ""), false); const std::string versionStr = jsonLayer->getAsString("version", ""); WMSServerVersion mapServerVersion = WMS_1_1_0; if (versionStr.compare("WMS_1_3_0") == 0) { mapServerVersion = WMS_1_3_0; } const std::string queryLayer = jsonLayer->getAsString("queryLayer", ""); const std::string style = jsonLayer->getAsString("style", ""); const URL queryServerURL = URL("", false); const WMSServerVersion queryServerVersion = mapServerVersion; const Sector sector = parseSector(jsonLayer, "validSector"); std::string imageFormat = jsonLayer->getAsString("imageFormat", "image/png"); const std::string srs = jsonLayer->getAsString("projection", "EPSG:4326"); LayerTilesRenderParameters* layerTilesRenderParameters = NULL; if (srs.compare("EPSG:4326") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters::createDefaultWGS84(0, 17); } else if (srs.compare("EPSG:3857") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters::createDefaultMercator(0, 17); } const double expiration = jsonLayer->getAsNumber("expiration", 0); const long long milliseconds = IMathUtils::instance()->round(expiration); const TimeInterval timeToCache = TimeInterval::fromMilliseconds(milliseconds); const bool readExpired = jsonLayer->getAsBoolean("acceptExpiration", false); return new WMSLayer(mapLayer, mapServerURL, mapServerVersion, queryLayer, queryServerURL, queryServerVersion, sector, imageFormat, srs, style, transparent, NULL, timeToCache, readExpired, layerTilesRenderParameters); } URLTemplateLayer* MapBooOLDBuilder::parseURLTemplateLayer(const JSONObject* jsonLayer, const bool transparent) const { const std::string urlTemplate = jsonLayer->getAsString("url", ""); const int firstLevel = (int) jsonLayer->getAsNumber("firstLevel", 1); const int maxLevel = (int) jsonLayer->getAsNumber("maxLevel", 19); const std::string projection = jsonLayer->getAsString("projection", "EPSG:3857"); const bool mercator = (projection == "EPSG:3857"); const Sector sector = parseSector(jsonLayer, "validSector"); URLTemplateLayer* result; if (mercator) { result = URLTemplateLayer::newMercator(urlTemplate, sector, transparent, firstLevel, maxLevel, TimeInterval::fromDays(30)); } else { result = new URLTemplateLayer(urlTemplate, sector, transparent, TimeInterval::fromDays(30), true, new LevelTileCondition(firstLevel, maxLevel), LayerTilesRenderParameters::createDefaultWGS84(sector, 1, maxLevel)); } return result; } Layer* MapBooOLDBuilder::parseLayer(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == NULL) { return NULL; } if (jsonBaseObjectLayer->asNull() != NULL) { return NULL; } const TimeInterval defaultTimeToCache = TimeInterval::fromDays(30); const JSONObject* jsonLayer = jsonBaseObjectLayer->asObject(); if (jsonLayer == NULL) { ILogger::instance()->logError("Layer is not a json object"); return NULL; } const bool transparent = jsonLayer->getAsBoolean("transparent", false); const std::string layerType = jsonLayer->getAsString("layer", "<layer not present>"); Layer* layer; if (layerType.compare("OSM") == 0) { layer = new OSMLayer(defaultTimeToCache, true, 2, 1, NULL, new std::vector<const Info*>()); } else if (layerType.compare("MapQuest") == 0) { layer = parseMapQuestLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("BingMaps") == 0) { layer = parseBingMapsLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("CartoDB") == 0) { layer = parseCartoDBLayer(jsonLayer, transparent, defaultTimeToCache); } else if (layerType.compare("MapBox") == 0) { layer = parseMapBoxLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("WMS") == 0) { layer = parseWMSLayer(jsonLayer, transparent); } else if (layerType.compare("URLTemplate") == 0) { layer = parseURLTemplateLayer(jsonLayer, transparent); } else { ILogger::instance()->logError("Unsupported layer type \"%s\"", layerType.c_str()); ILogger::instance()->logError("%s", jsonBaseObjectLayer->description().c_str()); return NULL; } const std::string layerAttribution = jsonLayer->getAsString("attribution", ""); if (layerAttribution.compare("") != 0) { layer->addInfo(new Info(layerAttribution)); } return layer; } Color MapBooOLDBuilder::parseColor(const JSONString* jsonColor) const { if (jsonColor == NULL) { return Color::black(); } const Color* color = Color::parse(jsonColor->value()); if (color == NULL) { ILogger::instance()->logError("Invalid format in attribute 'color' (%s)", jsonColor->value().c_str()); return Color::black(); } Color result(*color); delete color; return result; } MapBooOLD_MultiImage_Level* MapBooOLDBuilder::parseMultiImageLevel(const JSONObject* jsonObject) const { const JSONString* jsURL = jsonObject->getAsString("url"); if (jsURL == NULL) { return NULL; } const JSONNumber* jsWidth = jsonObject->getAsNumber("width"); if (jsWidth == NULL) { return NULL; } const JSONNumber* jsHeight = jsonObject->getAsNumber("height"); if (jsHeight == NULL) { return NULL; } return new MapBooOLD_MultiImage_Level(URL(_serverURL, "/images/" + jsURL->value()), (int) jsWidth->value(), (int) jsHeight->value()); } MapBooOLD_MultiImage* MapBooOLDBuilder::parseMultiImage(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } Color averageColor = parseColor( jsonObject->getAsString("averageColor") ); std::vector<MapBooOLD_MultiImage_Level*> levels; const JSONArray* jsLevels = jsonObject->getAsArray("levels"); if (jsLevels != NULL) { const size_t levelsCount = jsLevels->size(); for (size_t i = 0; i < levelsCount; i++) { MapBooOLD_MultiImage_Level* level = parseMultiImageLevel( jsLevels->getAsObject(i) ); if (level != NULL) { levels.push_back(level); } } } return new MapBooOLD_MultiImage(averageColor, levels); } const MapBooOLD_CameraPosition* MapBooOLDBuilder::parseCameraPosition(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } const double latitudeInDegress = jsonObject->getAsNumber("latitude", 0); const double longitudeInDegress = jsonObject->getAsNumber("longitude", 0); const double height = jsonObject->getAsNumber("height", 0); const double headingInDegrees = jsonObject->getAsNumber("heading", 0); const double pitchInDegrees = jsonObject->getAsNumber("pitch", 0); const bool animated = jsonObject->getAsBoolean("animated", true); return new MapBooOLD_CameraPosition(Geodetic3D::fromDegrees(latitudeInDegress, longitudeInDegress, height), Angle::fromDegrees(headingInDegrees), Angle::fromDegrees(pitchInDegrees), animated); } Sector* MapBooOLDBuilder::parseSector(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == NULL) { return NULL; } if (jsonBaseObjectLayer->asNull() != NULL) { return NULL; } const JSONObject* jsonObject = jsonBaseObjectLayer->asObject(); if (jsonObject == NULL) { return NULL; } const double lowerLat = jsonObject->getAsNumber("lowerLat", -90.0); const double lowerLon = jsonObject->getAsNumber("lowerLon", -180.0); const double upperLat = jsonObject->getAsNumber("upperLat", 90.0); const double upperLon = jsonObject->getAsNumber("upperLon", 180.0); return new Sector(Geodetic2D::fromDegrees(lowerLat, lowerLon), Geodetic2D::fromDegrees(upperLat, upperLon)); } const Sector MapBooOLDBuilder::parseSector(const JSONObject* jsonObject, const std::string& paramName) const { const JSONObject* sector = jsonObject->getAsObject(paramName); if (sector == NULL) { return Sector::fullSphere(); } if (sector->asNull() != NULL) { return Sector::fullSphere(); } const double lowerLat = sector->getAsNumber("lowerLat", -90.0); const double lowerLon = sector->getAsNumber("lowerLon", -180.0); const double upperLat = sector->getAsNumber("upperLat", 90.0); const double upperLon = sector->getAsNumber("upperLon", 180.0); return Sector(Geodetic2D::fromDegrees(lowerLat, lowerLon), Geodetic2D::fromDegrees(upperLat, upperLon)); } MapBooOLD_Scene* MapBooOLDBuilder::parseScene(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } const bool hasWarnings = jsonObject->getAsBoolean("hasWarnings", false); const bool queryable = jsonObject->getAsBoolean("queryable", false); return new MapBooOLD_Scene(jsonObject->getAsString("id", ""), jsonObject->getAsString("name", ""), jsonObject->getAsString("description", ""), parseMultiImage( jsonObject->getAsObject("screenshot") ), parseColor( jsonObject->getAsString("backgroundColor") ), parseCameraPosition( jsonObject->getAsObject("cameraPosition") ), parseSector( jsonObject->get("sector") ), parseLayer( jsonObject->get("baseLayer") ), parseLayer( jsonObject->get("overlayLayer") ), queryable, hasWarnings); } const URL* MapBooOLDBuilder::parseURL(const JSONString* jsonString) const { if (jsonString == NULL) { return NULL; } return new URL(jsonString->value()); } MapBooOLD_Notification* MapBooOLDBuilder::parseNotification(const JSONObject* jsonObject) const { if (jsonObject == NULL) { return NULL; } return new MapBooOLD_Notification(Geodetic2D::fromDegrees(jsonObject->getAsNumber("latitude", 0), jsonObject->getAsNumber("longitude", 0)), parseCameraPosition( jsonObject->getAsObject("cameraPosition") ), jsonObject->getAsString("message", ""), parseURL( jsonObject->getAsString("iconURL") ) ); } std::vector<MapBooOLD_Notification*>* MapBooOLDBuilder::parseNotifications(const JSONArray* jsonArray) const { std::vector<MapBooOLD_Notification*>* result = new std::vector<MapBooOLD_Notification*>(); if (jsonArray != NULL) { const size_t size = jsonArray->size(); for (size_t i = 0; i < size; i++) { MapBooOLD_Notification* notification = parseNotification( jsonArray->getAsObject(i) ); if (notification != NULL) { result->push_back(notification); } } } return result; } void MapBooOLDBuilder::parseApplicationEventsJSON(const std::string& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser::instance()->parse(json, true); if (jsonBaseObject == NULL) { ILogger::instance()->logError("Can't parse ApplicationJSON from %s", url._path.c_str()); } else { const JSONArray* jsonArray = jsonBaseObject->asArray(); if (jsonArray != NULL) { const size_t size = jsonArray->size(); for (size_t i = 0; i < size; i++) { const JSONObject* jsonObject = jsonArray->getAsObject(i); parseApplicationJSON(jsonObject, url); } } else { parseApplicationJSON(json, url); } } delete jsonBaseObject; } void MapBooOLDBuilder::parseApplicationJSON(const JSONObject* jsonObject, const URL& url) { std::vector<std::string> errors; if (jsonObject == NULL) { ILogger::instance()->logError("Invalid ApplicationJSON"); } else { const JSONString* jsonError = jsonObject->getAsString("error"); if (jsonError == NULL) { const int eventId = (int) jsonObject->getAsNumber("eventId", 0); const int timestamp = (int) jsonObject->getAsNumber("timestamp", 0); if (getApplicationEventId() != eventId) { const JSONString* jsonName = jsonObject->getAsString("name"); if (jsonName != NULL) { setApplicationName( jsonName->value() ); } const JSONString* jsonWebsite = jsonObject->getAsString("website"); if (jsonWebsite != NULL) { setApplicationWebsite( jsonWebsite->value() ); } const JSONString* jsonEMail = jsonObject->getAsString("email"); if (jsonEMail != NULL) { setApplicationEMail( jsonEMail->value() ); } const JSONString* jsonAbout = jsonObject->getAsString("about"); if (jsonAbout != NULL) { setApplicationAbout( jsonAbout->value() ); } const JSONObject* jsonScene = jsonObject->getAsObject("scene"); if (jsonScene != NULL) { parseSceneEventAndUpdateScene(jsonScene); } const JSONArray* jsonAllScenes = jsonObject->getAsArray("scenes"); if (jsonAllScenes != NULL) { std::vector<MapBooOLD_Scene*> scenes; const size_t scenesCount = jsonAllScenes->size(); for (size_t i = 0; i < scenesCount; i++) { MapBooOLD_Scene* scene = parseScene( jsonAllScenes->getAsObject(i) ); if (scene != NULL) { scenes.push_back(scene); } } setApplicationScenes(scenes); } const JSONObject* jsonScenes = jsonObject->getAsObject("scenes"); if (jsonScenes != NULL) { const JSONObject* jsonPutScene = jsonScenes->getAsObject("putScene"); if (jsonPutScene != NULL) { const JSONNumber* jsonPosition = jsonPutScene->getAsNumber("position"); int position = (jsonPosition != NULL) ? (int) jsonPosition->value() : 0; const JSONObject* jsonNewScene = jsonPutScene->getAsObject("scene"); if (jsonNewScene != NULL) { MapBooOLD_Scene* scene = parseScene(jsonNewScene); if (scene != NULL) { addApplicationScene(scene, position); } } } else { const JSONObject* jsonDeleteScene = jsonScenes->getAsObject("deleteScene"); if (jsonDeleteScene != NULL) { const JSONString* jsonSceneId = jsonDeleteScene->getAsString("sceneId"); if (jsonSceneId != NULL) { deleteApplicationScene(jsonSceneId->value()); } } } } setApplicationEventId(eventId); setApplicationTimestamp(timestamp); saveApplicationData(); setHasParsedApplication(); } const JSONString* jsonCurrentSceneId = jsonObject->getAsString("currentSceneId"); if (jsonCurrentSceneId != NULL) { setApplicationCurrentSceneId( jsonCurrentSceneId->value() ); } if (_enableNotifications) { const JSONArray* jsonNotifications = jsonObject->getAsArray("notifications"); if (jsonNotifications != NULL) { addApplicationNotifications( parseNotifications(jsonNotifications) ); } const JSONObject* jsonNotification = jsonObject->getAsObject("notification"); if (jsonNotification != NULL) { addApplicationNotification( parseNotification(jsonNotification) ); } } if (_initialParse) { _initialParse = false; if (_applicationCurrentSceneId.compare("-1") == 0) { if (_applicationScenes.size() > 0) { setApplicationCurrentSceneId(_applicationScenes.at(0)->getId()); } } } } else { errors.push_back(jsonError->value().c_str()); ILogger::instance()->logError("Server Error: %s", jsonError->value().c_str()); if (_initialParse) { _initialParse = false; setHasParsedApplication(); } } } _mbErrorRenderer->setErrors(errors); } void MapBooOLDBuilder::parseApplicationJSON(const std::string& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser::instance()->parse(json, true); if (jsonBaseObject == NULL) { ILogger::instance()->logError("Can't parse ApplicationJSON from %s", url._path.c_str()); } else { const JSONObject* jsonObject = jsonBaseObject->asObject(); parseApplicationJSON(jsonObject, url); } delete jsonBaseObject; } void MapBooOLDBuilder::parseSceneEventAndUpdateScene(const JSONObject* jsonObject) { if (jsonObject == NULL) { return; } const JSONString* jsonSceneToBeUpdatedID = jsonObject->getAsString("id"); if (jsonSceneToBeUpdatedID == NULL) { return; } const std::string sceneToBeUpdatedID = jsonSceneToBeUpdatedID->value(); const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneID = _applicationScenes[i]->getId(); if (sceneID.compare(sceneToBeUpdatedID) == 0) { MapBooOLD_Scene* oldScene = _applicationScenes[i]; const std::string name = jsonObject->getAsString("name", oldScene->getName()); const std::string description = jsonObject->getAsString("description", oldScene->getDescription()); const JSONBaseObject* jboScreenshot = jsonObject->get("screenshot"); const MapBooOLD_MultiImage* screenshot; if (jboScreenshot != NULL) { screenshot = parseMultiImage(jboScreenshot->asObject()); } else { const MapBooOLD_MultiImage* oldScreenshot = oldScene->getScreenshot(); screenshot = (oldScreenshot != NULL) ? oldScreenshot->deepCopy() : NULL; } const JSONBaseObject* jboBackgroundColor = jsonObject->get("backgroundColor"); const Color backgroundColor = (jboBackgroundColor != NULL) ? parseColor(jboBackgroundColor->asString()) : oldScene->getBackgroundColor(); const JSONBaseObject* jboCameraPosition = jsonObject->get("cameraPosition"); const MapBooOLD_CameraPosition* cameraPosition; if (jboCameraPosition != NULL) { cameraPosition = parseCameraPosition(jboCameraPosition->asObject()); } else { const MapBooOLD_CameraPosition* oldCameraPosition = oldScene->getCameraPosition(); cameraPosition = (oldCameraPosition != NULL) ? new MapBooOLD_CameraPosition(oldCameraPosition->getPosition(), oldCameraPosition->getHeading(), oldCameraPosition->getPitch(), oldCameraPosition->isAnimated()) : NULL ; } const JSONBaseObject* jboSector = jsonObject->get("sector"); const Sector* sector; if (jboSector != NULL) { sector = parseSector(jboSector->asObject()); } else { const Sector* oldSector = oldScene->getSector(); sector = (oldSector != NULL) ? new Sector(oldSector->_lower, oldSector->_upper) : NULL; } const JSONBaseObject* jboBaseLayer = jsonObject->get("baseLayer"); Layer* baseLayer = (jboBaseLayer != NULL) ? parseLayer(jboBaseLayer->asObject()) : oldScene->getBaseLayer()->copy(); const JSONBaseObject* jboOverlayLayer = jsonObject->get("overlayLayer"); Layer* oldOverlayLayer = (oldScene->getOverlayLayer() != NULL) ? oldScene->getOverlayLayer()->copy() : NULL; Layer* overlayLayer = (jboOverlayLayer != NULL) ? parseLayer(jboOverlayLayer->asObject()) : oldOverlayLayer; const bool hasWarnings = jsonObject->getAsBoolean("hasWarnings", false); const bool queryable = jsonObject->getAsBoolean("queryable", oldScene->isQueryable()); const bool cameraPositionChaged = (jboCameraPosition != NULL); MapBooOLD_Scene* newScene = new MapBooOLD_Scene(sceneToBeUpdatedID, name, description, screenshot, backgroundColor, cameraPosition, sector, baseLayer, overlayLayer, queryable, hasWarnings); _applicationScenes[i] = newScene; if (sceneID.compare(_applicationCurrentSceneId) == 0) { updateVisibleScene(cameraPositionChaged); } if (_applicationListener != NULL) { _applicationListener->onSceneChanged(_context, newScene); } fireOnScenesChanged(); delete oldScene; break; } } } void MapBooOLDBuilder::addApplicationNotifications(const std::vector<MapBooOLD_Notification*>* notifications) { if (notifications == NULL) { return; } const size_t size = notifications->size(); for (size_t i = 0; i < size; i++) { MapBooOLD_Notification* notification = notifications->at(i); if (notification != NULL) { addApplicationNotification(notification); } } delete notifications; } void MapBooOLDBuilder::addApplicationNotification(MapBooOLD_Notification* notification) { if (_marksRenderer != NULL) { const std::string message = notification->getMessage(); const bool hasMessage = (message.size() > 0); const URL* iconURL = notification->getIconURL(); const Geodetic2D position = notification->getPosition(); bool newMark = false; if (hasMessage) { if (iconURL == NULL) { _marksRenderer->addMark( new Mark(message, Geodetic3D(position, 0), ABSOLUTE, 0) ); } else { _marksRenderer->addMark( new Mark(message, *iconURL, Geodetic3D(position, 0), ABSOLUTE, 0) ); } newMark = true; } else { if (iconURL != NULL) { _marksRenderer->addMark( new Mark(*iconURL, Geodetic3D(position, 0), ABSOLUTE, 0) ); newMark = true; } } if (newMark) { const MapBooOLD_CameraPosition* cameraPosition = notification->getCameraPosition(); if (cameraPosition != NULL) { setCameraPosition(cameraPosition, true); } } } delete notification; } void MapBooOLDBuilder::setApplicationCurrentSceneId(const std::string& currentSceneId) { if (_applicationCurrentSceneId.compare(currentSceneId) != 0) { const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneId = _applicationScenes[i]->getId(); if (sceneId.compare(currentSceneId) == 0) { _applicationCurrentSceneId = currentSceneId; changedCurrentScene(); break; } } } } LayerSet* MapBooOLD_Scene::createLayerSet() const { LayerSet* layerSet = new LayerSet(); if (_baseLayer != NULL) { layerSet->addLayer(_baseLayer->copy()); } if (_overlayLayer != NULL) { layerSet->addLayer(_overlayLayer->copy()); } return layerSet; } void MapBooOLDBuilder::recreateLayerSet() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); if (scene == NULL) { _layerSet->removeAllLayers(true); } else { LayerSet* newLayerSet = scene->createLayerSet(); if (!newLayerSet->isEquals(_layerSet)) { _layerSet->removeAllLayers(true); _layerSet->takeLayersFrom(newLayerSet); } delete newLayerSet; } } const URL MapBooOLDBuilder::createApplicationTubeURL() const { const std::string tubesPath = _tubesURL._path; std::string view; switch (_viewType) { case VIEW_PRESENTATION: view = "presentation"; break; case VIEW_EDITION_PREVIEW: view = "edition-preview"; break; default: view = "runtime"; } return URL(tubesPath + "/application/" + _applicationId + "/" + view, false); } class MapBooOLDBuilder_TubeWatchdogPeriodicalTask : public GTask { private: MapBooOLDBuilder* _builder; bool _firstRun; public: MapBooOLDBuilder_TubeWatchdogPeriodicalTask(MapBooOLDBuilder* builder) : _builder(builder), _firstRun(true) { } void run(const G3MContext* context) { if (_firstRun) { _firstRun = false; } else { if (!_builder->isApplicationTubeOpen()) { _builder->pollApplicationDataFromServer(context); _builder->openApplicationTube(context); } } } }; std::vector<PeriodicalTask*>* MapBooOLDBuilder::createPeriodicalTasks() { std::vector<PeriodicalTask*>* periodicalTasks = new std::vector<PeriodicalTask*>(); periodicalTasks->push_back(new PeriodicalTask(TimeInterval::fromSeconds(5), new MapBooOLDBuilder_TubeWatchdogPeriodicalTask(this))); return periodicalTasks; } IStorage* MapBooOLDBuilder::getStorage() { if (_storage == NULL) { _storage = createStorage(); } return _storage; } class MapBooOLDBuilder_ApplicationTubeListener : public IWebSocketListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeListener(MapBooOLDBuilder* builder) : _builder(builder) { } ~MapBooOLDBuilder_ApplicationTubeListener() { } void onOpen(IWebSocket* ws) { ILogger::instance()->logInfo("Tube '%s' opened!", ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(true); } void onError(IWebSocket* ws, const std::string& error) { ILogger::instance()->logError("Error '%s' on Tube '%s'", error.c_str(), ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(false); } void onMessage(IWebSocket* ws, const std::string& message) { _builder->parseApplicationJSON(message, ws->getURL()); } void onClose(IWebSocket* ws) { ILogger::instance()->logError("Tube '%s' closed!", ws->getURL()._path.c_str()); _builder->setApplicationTubeOpened(false); } }; class MapBooOLDBuilder_ApplicationTubeConnector : public GInitializationTask { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeConnector(MapBooOLDBuilder* builder) : _builder(builder) { } void run(const G3MContext* context) { _builder->setContext(context); _builder->openApplicationTube(context); } bool isDone(const G3MContext* context) { return _builder->hasParsedApplication(); } }; void MapBooOLDBuilder::setContext(const G3MContext* context) { _context = context; } MapBooOLDBuilder::~MapBooOLDBuilder() { } class MapBooOLDBuilder_RestJSON : public IBufferDownloadListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_RestJSON(MapBooOLDBuilder* builder) : _builder(builder) { } void onDownload(const URL& url, IByteBuffer* buffer, bool expired) { _builder->parseApplicationEventsJSON(buffer->getAsString(), url); delete buffer; } void onError(const URL& url) { ILogger::instance()->logError("Can't download %s", url._path.c_str()); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, bool expired) { } }; const URL MapBooOLDBuilder::createApplicationPollURL() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString(_serverURL._path); isb->addString("/poll/"); isb->addString(_applicationId); isb->addString("?view="); isb->addString(getViewAsString()); isb->addString("&eventId="); isb->addInt(_applicationEventId); const std::string path = isb->getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder::openApplicationTube(const G3MContext* context) { const IFactory* factory = context->getFactory(); _webSocket = factory->createWebSocket(createApplicationTubeURL(), new MapBooOLDBuilder_ApplicationTubeListener(this), true , true ); } const std::string MapBooOLDBuilder::getApplicationCurrentSceneId() { return _applicationCurrentSceneId; } const MapBooOLD_Scene* MapBooOLDBuilder::getApplicationCurrentScene() { const std::string currentSceneId = getApplicationCurrentSceneId(); const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string sceneId = _applicationScenes[i]->getId(); if (sceneId.compare(currentSceneId) == 0) { return _applicationScenes[i]; } } return NULL; } Color MapBooOLDBuilder::getCurrentBackgroundColor() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); return (scene == NULL) ? Color::black() : scene->getBackgroundColor(); } MarksRenderer* MapBooOLDBuilder::getMarksRenderer() { if (_marksRenderer == NULL) { _marksRenderer = new MarksRenderer(false); } return _marksRenderer; } G3MWidget* MapBooOLDBuilder::create() { if (_g3mWidget != NULL) { ILogger::instance()->logError("The G3MWidget was already created, can't be created more than once"); return NULL; } CompositeRenderer* mainRenderer = new CompositeRenderer(); _mbErrorRenderer = new MapBooOLD_ErrorRenderer(); mainRenderer->addRenderer(_mbErrorRenderer); const Planet* planet = createPlanet(); PlanetRenderer* planetRenderer = createPlanetRenderer(); mainRenderer->addRenderer(planetRenderer); mainRenderer->addRenderer(getMarksRenderer()); std::vector<ICameraConstrainer*>* cameraConstraints = createCameraConstraints(planet, planetRenderer); GInitializationTask* initializationTask = new MapBooOLDBuilder_ApplicationTubeConnector(this); std::vector<PeriodicalTask*>* periodicalTasks = createPeriodicalTasks(); ICameraActivityListener* cameraActivityListener = NULL; InitialCameraPositionProvider* icpp = new SimpleInitialCameraPositionProvider(); MapBooOLD_HUDRenderer* hudRenderer = new MapBooOLD_HUDRenderer(); InfoDisplay* infoDisplay = new MapBooOLD_HUDRendererInfoDisplay(hudRenderer); infoDisplay->showDisplay(); _g3mWidget = G3MWidget::create(getGL(), getStorage(), getDownloader(), getThreadUtils(), cameraActivityListener, planet, *cameraConstraints, createCameraRenderer(), mainRenderer, createBusyRenderer(), createErrorRenderer(), hudRenderer, Color::black(), false, false, initializationTask, true, *periodicalTasks, getGPUProgramManager(), createSceneLighting(), icpp, infoDisplay, MONO); delete cameraConstraints; delete periodicalTasks; return _g3mWidget; } int MapBooOLDBuilder::getApplicationEventId() const { return _applicationEventId; } void MapBooOLDBuilder::setApplicationEventId(const int eventId) { _applicationEventId = eventId; } int MapBooOLDBuilder::getApplicationTimestamp() const { return _applicationTimestamp; } const std::string MapBooOLDBuilder::getApplicationId() { return _applicationId; } void MapBooOLDBuilder::saveApplicationData() const { } void MapBooOLDBuilder::setHasParsedApplication() { _hasParsedApplication = true; } bool MapBooOLDBuilder::hasParsedApplication() const { return _hasParsedApplication; } void MapBooOLDBuilder::setApplicationTimestamp(const int timestamp) { _applicationTimestamp = timestamp; } void MapBooOLDBuilder::setApplicationName(const std::string& name) { if (_applicationName.compare(name) != 0) { _applicationName = name; if (_applicationListener != NULL) { _applicationListener->onNameChanged(_context, _applicationName); } } } void MapBooOLDBuilder::setApplicationWebsite(const std::string& website) { if (_applicationWebsite.compare(website) != 0) { _applicationWebsite = website; if (_applicationListener != NULL) { _applicationListener->onWebsiteChanged(_context, _applicationWebsite); } } } void MapBooOLDBuilder::setApplicationEMail(const std::string& eMail) { if (_applicationEMail.compare(eMail) != 0) { _applicationEMail = eMail; if (_applicationListener != NULL) { _applicationListener->onEMailChanged(_context, _applicationEMail); } } } void MapBooOLDBuilder::setApplicationAbout(const std::string& about) { if (_applicationAbout.compare(about) != 0) { _applicationAbout = about; if (_applicationListener != NULL) { _applicationListener->onAboutChanged(_context, _applicationAbout); } } } class MapBooOLDBuilder_ChangeSceneTask : public GTask { private: MapBooOLDBuilder* _builder; const std::string _sceneId; public: MapBooOLDBuilder_ChangeSceneTask(MapBooOLDBuilder* builder, const std::string& sceneId) : _builder(builder), _sceneId(sceneId) { } void run(const G3MContext* context) { _builder->rawChangeScene(_sceneId); } }; void MapBooOLDBuilder::rawChangeScene(const std::string& sceneId) { _applicationCurrentSceneId = sceneId; changedCurrentScene(); } void MapBooOLDBuilder::changeScene(const std::string& sceneId) { const std::string currentSceneId = getApplicationCurrentSceneId(); if (currentSceneId.compare(sceneId) != 0) { const size_t scenesCount = _applicationScenes.size(); for (size_t i = 0; i < scenesCount; i++) { const std::string iSceneId = _applicationScenes[i]->getId(); if (sceneId.compare(iSceneId) == 0) { getThreadUtils()->invokeInRendererThread(new MapBooOLDBuilder_ChangeSceneTask(this, sceneId), true); break; } } } } void MapBooOLDBuilder::changeScene(const MapBooOLD_Scene* scene) { const size_t size = _applicationScenes.size(); for (size_t i = 0; i < size; i++) { if (_applicationScenes[i] == scene) { changeScene(scene->getId()); break; } } } class MapBooOLDBuilder_DummyListener : public IBufferDownloadListener { public: MapBooOLDBuilder_DummyListener() { } void onDownload(const URL& url, IByteBuffer* buffer, bool expired) { delete buffer; } void onError(const URL& url) { ILogger::instance()->logError("Can't download %s", url._path.c_str()); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, bool expired) { } }; void MapBooOLDBuilder::changedCurrentScene() { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != NULL) { _g3mWidget->setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget->resetPeriodicalTasksTimeouts(); if (currentScene != NULL) { const Sector* sector = currentScene->getSector(); if (sector == NULL) { _g3mWidget->setRenderedSector( Sector::fullSphere() ); } else { _g3mWidget->setRenderedSector( *sector ); } setCameraPosition(currentScene->getCameraPosition()); } } if (_applicationListener != NULL) { _applicationListener->onCurrentSceneChanged(_context, getApplicationCurrentSceneId(), currentScene); } if (_viewType == VIEW_EDITION_PREVIEW) { if (_applicationCurrentSceneId.compare(_lastApplicationCurrentSceneId) != 0) { if (_lastApplicationCurrentSceneId.compare("-1") != 0) { if (_webSocket != NULL && _isApplicationTubeOpen) { _webSocket->send( getApplicationCurrentSceneCommand() ); } else if (_token.length() > 0) { _g3mWidget->getG3MContext()->getDownloader()->requestBuffer(createApplicationCurrentSceneURL(), DownloadPriority::HIGHEST, TimeInterval::zero(), false, new MapBooOLDBuilder_DummyListener(), false); } else { ILogger::instance()->logError("VIEW_PRESENTATION: can't fire the event of changed scene"); } } _lastApplicationCurrentSceneId = _applicationCurrentSceneId; } } } const std::string MapBooOLDBuilder::getApplicationCurrentSceneCommand() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString("currentSceneId="); isb->addString(_applicationCurrentSceneId); const std::string s = isb->getString(); delete isb; return s; } const URL MapBooOLDBuilder::createApplicationCurrentSceneURL() const { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString(_serverURL._path); isb->addString("/REST/1/applications/"); isb->addString(_applicationId); isb->addString("/_POST_?"); isb->addString("currentSceneId="); isb->addString(_applicationCurrentSceneId); isb->addString("&token="); isb->addString(_token); const std::string path = isb->getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder::updateVisibleScene(const bool cameraPositionChanged) { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != NULL) { _g3mWidget->setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget->resetPeriodicalTasksTimeouts(); if (currentScene != NULL) { const Sector* sector = currentScene->getSector(); if (sector == NULL) { _g3mWidget->setRenderedSector( Sector::fullSphere() ); } else { _g3mWidget->setRenderedSector( *sector ); } if (cameraPositionChanged) { setCameraPosition(currentScene->getCameraPosition()); } } } } void MapBooOLDBuilder::setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition, const bool animated) { if (cameraPosition != NULL) { if (animated) { _g3mWidget->setAnimatedCameraPosition(TimeInterval::fromSeconds(3), cameraPosition->getPosition(), cameraPosition->getHeading(), cameraPosition->getPitch()); } else { _g3mWidget->setCameraPosition( cameraPosition->getPosition() ); _g3mWidget->setCameraHeading( cameraPosition->getHeading() ); _g3mWidget->setCameraPitch( cameraPosition->getPitch() ); } } } void MapBooOLDBuilder::setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition) { if (cameraPosition != NULL) { const bool animated = cameraPosition->isAnimated(); setCameraPosition(cameraPosition, animated); } } void MapBooOLDBuilder::fireOnScenesChanged() { if (_applicationListener != NULL) { } } void MapBooOLDBuilder::addApplicationScene(MapBooOLD_Scene* scene, const int position) { fireOnScenesChanged(); } void MapBooOLDBuilder::deleteApplicationScene(const std::string &sceneId) { const int scenesCount = _applicationScenes.size(); int sceneIndex = -1; for (int i = 0; i < scenesCount; i++) { const std::string iSceneId = _applicationScenes[i]->getId(); if (iSceneId.compare(sceneId) == 0) { sceneIndex = i; break; } } if (sceneIndex != -1) { MapBooOLD_Scene* scene = _applicationScenes[sceneIndex]; delete scene; if (_viewType == VIEW_RUNTIME) { if (_applicationCurrentSceneId.compare(sceneId) == 0) { setApplicationCurrentSceneId(_applicationScenes[0]->getId()); } } fireOnScenesChanged(); } } void MapBooOLDBuilder::setApplicationScenes(const std::vector<MapBooOLD_Scene*>& applicationScenes) { const size_t currentScenesCount = _applicationScenes.size(); for (size_t i = 0; i < currentScenesCount; i++) { MapBooOLD_Scene* scene = _applicationScenes[i]; delete scene; } _applicationScenes.clear(); fireOnScenesChanged(); } SceneLighting* MapBooOLDBuilder::createSceneLighting() { return new CameraFocusSceneLighting(Color::fromRGBA((float)0.3, (float)0.3, (float)0.3, (float)1.0), Color::yellow()); } void MapBooOLDBuilder::setApplicationTubeOpened(bool open) { if (_isApplicationTubeOpen != open) { _isApplicationTubeOpen = open; if (!_isApplicationTubeOpen) { _webSocket = NULL; } if (_isApplicationTubeOpen) { if (_applicationListener != NULL) { _applicationListener->onWebSocketOpen(_context); } } else { if (_applicationListener != NULL) { _applicationListener->onWebSocketClose(_context); } } } } const MapBooOLD_Notification* MapBooOLDBuilder::createNotification(const Geodetic2D& position, const Camera* camera, const std::string& message, const URL* iconURL) const { MapBooOLD_CameraPosition* cameraPosition = new MapBooOLD_CameraPosition(camera->getGeodeticPosition(), camera->getHeading(), camera->getPitch(), true ); return new MapBooOLD_Notification(position, cameraPosition, message, iconURL); } void MapBooOLDBuilder::pollApplicationDataFromServer(const G3MContext *context) { IDownloader* downloader = context->getDownloader(); downloader->requestBuffer(createApplicationPollURL(), DownloadPriority::HIGHEST, TimeInterval::zero(), false, new MapBooOLDBuilder_RestJSON(this), true); } const std::string MapBooOLDBuilder::getViewAsString() const { switch (_viewType) { case VIEW_EDITION_PREVIEW: return "edition-preview"; case VIEW_PRESENTATION: return "presentation"; case VIEW_RUNTIME: default: return "runtime"; } } const URL MapBooOLDBuilder::createGetFeatureInfoRestURL(const Tile* tile, const Vector2I& tileDimension, const Vector2I& pixelPosition, const Geodetic3D& position) { IStringBuilder* isb = IStringBuilder::newStringBuilder(); isb->addString(_serverURL._path); isb->addString("/Public/applications/"); isb->addString(_applicationId); isb->addString("/scenes/"); const MapBooOLD_Scene* scene = getApplicationCurrentScene(); isb->addString(scene->getId()); isb->addString("/getinfo?"); isb->addString("tileX="); isb->addInt(tile->_column); isb->addString("&tileY="); isb->addInt(tile->_row); isb->addString("&tileLevel="); isb->addInt(tile->_level); isb->addString("&upperLat="); isb->addDouble(tile->_sector._upper._latitude._degrees); isb->addString("&lowerLat="); isb->addDouble(tile->_sector._lower._latitude._degrees); isb->addString("&upperLon="); isb->addDouble(tile->_sector._upper._longitude._degrees); isb->addString("&lowerLon="); isb->addDouble(tile->_sector._lower._longitude._degrees); isb->addString("&tileBBox="); isb->addString("TODO"); isb->addString("&tileWidth="); isb->addInt(tileDimension._x); isb->addString("&tileHeight="); isb->addInt(tileDimension._y); isb->addString("&pixelX="); isb->addInt(pixelPosition._x); isb->addString("&pixelY="); isb->addInt(pixelPosition._y); isb->addString("&lat="); isb->addDouble(position._latitude._degrees); isb->addString("&lon="); isb->addDouble(position._longitude._degrees); const std::string path = isb->getString(); delete isb; return URL(path, false); } const void MapBooOLDBuilder::requestGetFeatureInfo(const Tile* tile, const Vector2I& size, const Vector2I& pixel, const Geodetic3D& position) { _g3mWidget->getG3MContext()->getDownloader()->requestBuffer(createGetFeatureInfoRestURL(tile, size, pixel, position), DownloadPriority::HIGHER, TimeInterval::zero(), false, _featureInfoDownloadListener, false); } void HUDInfoRenderer_ImageFactory::drawOn(ICanvas* canvas, int width, int height) { std::vector<std::string> strings; const size_t size = _info.size(); for (size_t i = 0; i < size; i++) { strings.push_back(_info.at(i)->getText()); } ICanvasUtils::drawStringsOn(strings, canvas, width, height, Left, Bottom, Left, Color::white(), 11, 2, Color::transparent(), Color::black(), 5); } bool HUDInfoRenderer_ImageFactory::isEquals(const std::vector<const Info*>& v1, const std::vector<const Info*>& v2) const { const size_t size1 = v1.size(); const size_t size2 = v2.size(); if (size1 != size2) { return false; } for (size_t i = 0; i < size1; i++) { const Info* str1 = v1[i]; const Info* str2 = v2[i]; if (str1 != str2) { return false; } } return true; } bool HUDInfoRenderer_ImageFactory::setInfo(const std::vector<const Info*>& info) { if ( isEquals(_info, info) ) { return false; } _info.clear();_info.addAll(info);
  //Sector
//C++ TO JAVA CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
<<<<<<< HEAD boolean MapBooBuilder.onTerrainTouch(const G3MEventContext* ec, ======= boolean MapBooOLDBuilder.onTerrainTouch(const G3MEventContext* ec, >>>>>>> 882166c33bdf9946c54ea507ad5e1c47fb3e83e0 const Vector2F& pixel, const Camera* camera, const Geodetic3D& position, const Tile* tile) { if (_applicationListener != null) { _applicationListener.onTerrainTouch(this, ec, pixel, camera, position, tile); } return true; } PlanetRenderer* MapBooOLDBuilder.createPlanetRenderer() { const boolean skirted = true; TileTessellator* tessellator = new PlanetTileTessellator(skirted, Sector.fullSphere()); ElevationDataProvider* elevationDataProvider = null; const float verticalExaggeration = 1; TileTexturizer* texturizer = new DefaultTileTexturizer(new DownloaderImageBuilder(URL("http://www.mapboo.com/web/img/tileNotFound.jpg"))); const boolean renderDebug = false; const boolean forceFirstLevelTilesRenderOnStart = true; const boolean incrementalTileQuality = false; const Quality quality = QUALITY_LOW; const TilesRenderParameters* parameters = new TilesRenderParameters(renderDebug, forceFirstLevelTilesRenderOnStart, incrementalTileQuality, quality); const boolean showStatistics = false; long tileDownloadPriority = DownloadPriority.HIGHER; const Sector renderedSector = Sector.fullSphere(); const boolean renderTileMeshes = true; const boolean logTilesPetitions = false; ChangedRendererInfoListener* changedRendererInfoListener = null; TouchEventType touchEventTypeOfTerrainTouchListener = DownUp; PlanetRenderer* result = new PlanetRenderer(tessellator, elevationDataProvider, true, verticalExaggeration, texturizer, _layerSet, parameters, showStatistics, tileDownloadPriority, renderedSector, renderTileMeshes, logTilesPetitions, changedRendererInfoListener, touchEventTypeOfTerrainTouchListener, getTileLODTester(), getTileVisibilityTester()); if (_enableNotifications) { result.addTerrainTouchListener(new MapBooOLDBuilder_TerrainTouchListener(this)); } return result; } const Planet* MapBooOLDBuilder.createPlanet() { return SphericalPlanet.createEarth(); } java.util.ArrayList<ICameraConstrainer>* MapBooOLDBuilder.createCameraConstraints(const Planet* planet, PlanetRenderer* planetRenderer) { java.util.ArrayList<ICameraConstrainer>* cameraConstraints = new java.util.ArrayList<ICameraConstrainer>(); const Geodetic3D initialCameraPosition = planet.getDefaultCameraPosition(Sector.fullSphere()); cameraConstraints.push_back(new RenderedSectorCameraConstrainer(planetRenderer, initialCameraPosition._height * 1.2)); return cameraConstraints; } CameraRenderer* MapBooOLDBuilder.createCameraRenderer() { CameraRenderer* cameraRenderer = new CameraRenderer(); const boolean useInertia = true; cameraRenderer.addHandler(new CameraSingleDragHandler(useInertia)); cameraRenderer.addHandler(new CameraDoubleDragHandler()); cameraRenderer.addHandler(new CameraRotationHandler()); return cameraRenderer; } ProtoRenderer* MapBooOLDBuilder.createBusyRenderer() { return new BusyMeshRenderer(Color.newFromRGBA(0, 0, 0, 1)); } class Mapboo_ErrorMessagesCustomizer : public ErrorMessagesCustomizer { private: MapBooOLDBuilder* _mbBuilder; public: Mapboo_ErrorMessagesCustomizer(MapBooOLDBuilder* mbBuilder) { _mbBuilder = mbBuilder; } ~Mapboo_ErrorMessagesCustomizer() {} java.util.ArrayList<String> customize(const java.util.ArrayList<String>& errors) { java.util.ArrayList<String> customizedErrorMessages; const IStringUtils* stringUtils = IStringUtils.instance(); const int errorsSize = errors.size(); const String appNotFound = "Invalid request: Application #" + _mbBuilder.getApplicationId() + " not found"; for (int i = 0; i < errorsSize; i++) { String error = errors.at(i); if (stringUtils.beginsWith(error, appNotFound)) { customizedErrorMessages.push_back("Oops, application not found!"); break; } customizedErrorMessages.push_back(error); } return customizedErrorMessages; } }; ErrorRenderer* MapBooOLDBuilder.createErrorRenderer() { return new HUDErrorRenderer(new Mapboo_ErrorMessagesCustomizer(this)); } MapQuestLayer* MapBooOLDBuilder.parseMapQuestLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const String imagery = jsonLayer.getAsString("imagery", "<imagery not present>"); if (imagery.compare("OpenAerial") == 0) { return MapQuestLayer.newOpenAerial(timeToCache); } return MapQuestLayer.newOSM(timeToCache); } BingMapsLayer* MapBooOLDBuilder.parseBingMapsLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const String key = jsonLayer.getAsString("key", ""); const String imagerySet = jsonLayer.getAsString("imagerySet", "Aerial"); return new BingMapsLayer(imagerySet, key, timeToCache, true, 2, 25, 1, null, new java.util.ArrayList<Info>()); } CartoDBLayer* MapBooOLDBuilder.parseCartoDBLayer(const JSONObject* jsonLayer, const boolean transparent, const TimeInterval& timeToCache) const { const String userName = jsonLayer.getAsString("userName", ""); const String table = jsonLayer.getAsString("table", ""); return new CartoDBLayer(userName, table, timeToCache, true, 1, transparent, null, new java.util.ArrayList<Info>()); } MapBoxLayer* MapBooOLDBuilder.parseMapBoxLayer(const JSONObject* jsonLayer, const TimeInterval& timeToCache) const { const String mapKey = jsonLayer.getAsString("mapKey", ""); return new MapBoxLayer(mapKey, timeToCache, true, 1, 19, 1, null, new java.util.ArrayList<Info>()); } WMSLayer* MapBooOLDBuilder.parseWMSLayer(const JSONObject* jsonLayer, const boolean transparent) const { const String mapLayer = jsonLayer.getAsString("layerName", ""); const URL mapServerURL = URL(jsonLayer.getAsString("server", ""), false); const String versionStr = jsonLayer.getAsString("version", ""); WMSServerVersion mapServerVersion = WMS_1_1_0; if (versionStr.compare("WMS_1_3_0") == 0) { mapServerVersion = WMS_1_3_0; } const String queryLayer = jsonLayer.getAsString("queryLayer", ""); const String style = jsonLayer.getAsString("style", ""); const URL queryServerURL = URL("", false); const WMSServerVersion queryServerVersion = mapServerVersion; const Sector sector = parseSector(jsonLayer, "validSector"); String imageFormat = jsonLayer.getAsString("imageFormat", "image/png"); const String srs = jsonLayer.getAsString("projection", "EPSG:4326"); LayerTilesRenderParameters* layerTilesRenderParameters = null; if (srs.compare("EPSG:4326") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters.createDefaultWGS84(0, 17); } else if (srs.compare("EPSG:3857") == 0) { layerTilesRenderParameters = LayerTilesRenderParameters.createDefaultMercator(0, 17); } const double expiration = jsonLayer.getAsNumber("expiration", 0); const long milliseconds = IMathUtils.instance().round(expiration); const TimeInterval timeToCache = TimeInterval.fromMilliseconds(milliseconds); const boolean readExpired = jsonLayer.getAsBoolean("acceptExpiration", false); return new WMSLayer(mapLayer, mapServerURL, mapServerVersion, queryLayer, queryServerURL, queryServerVersion, sector, imageFormat, srs, style, transparent, null, timeToCache, readExpired, layerTilesRenderParameters); } URLTemplateLayer* MapBooOLDBuilder.parseURLTemplateLayer(const JSONObject* jsonLayer, const boolean transparent) const { const String urlTemplate = jsonLayer.getAsString("url", ""); const int firstLevel = (int) jsonLayer.getAsNumber("firstLevel", 1); const int maxLevel = (int) jsonLayer.getAsNumber("maxLevel", 19); const String projection = jsonLayer.getAsString("projection", "EPSG:3857"); const boolean mercator = (projection.equals("EPSG:3857")); const Sector sector = parseSector(jsonLayer, "validSector"); URLTemplateLayer* result; if (mercator) { result = URLTemplateLayer.newMercator(urlTemplate, sector, transparent, firstLevel, maxLevel, TimeInterval.fromDays(30)); } else { result = new URLTemplateLayer(urlTemplate, sector, transparent, TimeInterval.fromDays(30), true, new LevelTileCondition(firstLevel, maxLevel), LayerTilesRenderParameters.createDefaultWGS84(sector, 1, maxLevel)); } return result; } Layer* MapBooOLDBuilder.parseLayer(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == null) { return null; } if (jsonBaseObjectLayer.asNull() != null) { return null; } const TimeInterval defaultTimeToCache = TimeInterval.fromDays(30); const JSONObject* jsonLayer = jsonBaseObjectLayer.asObject(); if (jsonLayer == null) { ILogger.instance().logError("Layer is not a json object"); return null; } const boolean transparent = jsonLayer.getAsBoolean("transparent", false); const String layerType = jsonLayer.getAsString("layer", "<layer not present>"); Layer* layer; if (layerType.compare("OSM") == 0) { layer = new OSMLayer(defaultTimeToCache, true, 2, 1, null, new java.util.ArrayList<Info>()); } else if (layerType.compare("MapQuest") == 0) { layer = parseMapQuestLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("BingMaps") == 0) { layer = parseBingMapsLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("CartoDB") == 0) { layer = parseCartoDBLayer(jsonLayer, transparent, defaultTimeToCache); } else if (layerType.compare("MapBox") == 0) { layer = parseMapBoxLayer(jsonLayer, defaultTimeToCache); } else if (layerType.compare("WMS") == 0) { layer = parseWMSLayer(jsonLayer, transparent); } else if (layerType.compare("URLTemplate") == 0) { layer = parseURLTemplateLayer(jsonLayer, transparent); } else { ILogger.instance().logError("Unsupported layer type \"%s\"", layerType); ILogger.instance().logError("%s", jsonBaseObjectLayer.description()); return null; } const String layerAttribution = jsonLayer.getAsString("attribution", ""); if (layerAttribution.compare("") != 0) { layer.addInfo(new Info(layerAttribution)); } return layer; } Color MapBooOLDBuilder.parseColor(const JSONString* jsonColor) const { if (jsonColor == null) { return Color.black(); } const Color* color = Color.parse(jsonColor.value()); if (color == null) { ILogger.instance().logError("Invalid format in attribute 'color' (%s)", jsonColor.value()); return Color.black(); } Color result(*color); delete color; return result; } MapBooOLD_MultiImage_Level* MapBooOLDBuilder.parseMultiImageLevel(const JSONObject* jsonObject) const { const JSONString* jsURL = jsonObject.getAsString("url"); if (jsURL == null) { return null; } const JSONNumber* jsWidth = jsonObject.getAsNumber("width"); if (jsWidth == null) { return null; } const JSONNumber* jsHeight = jsonObject.getAsNumber("height"); if (jsHeight == null) { return null; } return new MapBooOLD_MultiImage_Level(URL(_serverURL, "/images/" + jsURL.value()), (int) jsWidth.value(), (int) jsHeight.value()); } MapBooOLD_MultiImage* MapBooOLDBuilder.parseMultiImage(const JSONObject* jsonObject) const { if (jsonObject == null) { return null; } Color averageColor = parseColor(jsonObject.getAsString("averageColor")); java.util.ArrayList<MapBooOLD_MultiImage_Level> levels; const JSONArray* jsLevels = jsonObject.getAsArray("levels"); if (jsLevels != null) { const int levelsCount = jsLevels.size(); for (int i = 0; i < levelsCount; i++) { MapBooOLD_MultiImage_Level* level = parseMultiImageLevel(jsLevels.getAsObject(i)); if (level != null) { levels.push_back(level); } } } return new MapBooOLD_MultiImage(averageColor, levels); } const MapBooOLD_CameraPosition* MapBooOLDBuilder.parseCameraPosition(const JSONObject* jsonObject) const { if (jsonObject == null) { return null; } const double latitudeInDegress = jsonObject.getAsNumber("latitude", 0); const double longitudeInDegress = jsonObject.getAsNumber("longitude", 0); const double height = jsonObject.getAsNumber("height", 0); const double headingInDegrees = jsonObject.getAsNumber("heading", 0); const double pitchInDegrees = jsonObject.getAsNumber("pitch", 0); const boolean animated = jsonObject.getAsBoolean("animated", true); return new MapBooOLD_CameraPosition(Geodetic3D.fromDegrees(latitudeInDegress, longitudeInDegress, height), Angle.fromDegrees(headingInDegrees), Angle.fromDegrees(pitchInDegrees), animated); } Sector* MapBooOLDBuilder.parseSector(const JSONBaseObject* jsonBaseObjectLayer) const { if (jsonBaseObjectLayer == null) { return null; } if (jsonBaseObjectLayer.asNull() != null) { return null; } const JSONObject* jsonObject = jsonBaseObjectLayer.asObject(); if (jsonObject == null) { return null; } const double lowerLat = jsonObject.getAsNumber("lowerLat", -90.0); const double lowerLon = jsonObject.getAsNumber("lowerLon", -180.0); const double upperLat = jsonObject.getAsNumber("upperLat", 90.0); const double upperLon = jsonObject.getAsNumber("upperLon", 180.0); return new Sector(Geodetic2D.fromDegrees(lowerLat, lowerLon), Geodetic2D.fromDegrees(upperLat, upperLon)); } const Sector MapBooOLDBuilder.parseSector(const JSONObject* jsonObject, const String& paramName) const { const JSONObject* sector = jsonObject.getAsObject(paramName); if (sector == null) { return Sector.fullSphere(); } if (sector.asNull() != null) { return Sector.fullSphere(); } const double lowerLat = sector.getAsNumber("lowerLat", -90.0); const double lowerLon = sector.getAsNumber("lowerLon", -180.0); const double upperLat = sector.getAsNumber("upperLat", 90.0); const double upperLon = sector.getAsNumber("upperLon", 180.0); return Sector(Geodetic2D.fromDegrees(lowerLat, lowerLon), Geodetic2D.fromDegrees(upperLat, upperLon)); } MapBooOLD_Scene* MapBooOLDBuilder.parseScene(const JSONObject* jsonObject) const { if (jsonObject == null) { return null; } const boolean hasWarnings = jsonObject.getAsBoolean("hasWarnings", false); const boolean queryable = jsonObject.getAsBoolean("queryable", false); return new MapBooOLD_Scene(jsonObject.getAsString("id", ""), jsonObject.getAsString("name", ""), jsonObject.getAsString("description", ""), parseMultiImage(jsonObject.getAsObject("screenshot")), parseColor(jsonObject.getAsString("backgroundColor")), parseCameraPosition(jsonObject.getAsObject("cameraPosition")), parseSector(jsonObject.get("sector")), parseLayer(jsonObject.get("baseLayer")), parseLayer(jsonObject.get("overlayLayer")), queryable, hasWarnings); } const URL* MapBooOLDBuilder.parseURL(const JSONString* jsonString) const { if (jsonString == null) { return null; } return new URL(jsonString.value()); } MapBooOLD_Notification* MapBooOLDBuilder.parseNotification(const JSONObject* jsonObject) const { if (jsonObject == null) { return null; } return new MapBooOLD_Notification(Geodetic2D.fromDegrees(jsonObject.getAsNumber("latitude", 0), jsonObject.getAsNumber("longitude", 0)), parseCameraPosition(jsonObject.getAsObject("cameraPosition")), jsonObject.getAsString("message", ""), parseURL(jsonObject.getAsString("iconURL"))); } java.util.ArrayList<MapBooOLD_Notification>* MapBooOLDBuilder.parseNotifications(const JSONArray* jsonArray) const { java.util.ArrayList<MapBooOLD_Notification>* result = new java.util.ArrayList<MapBooOLD_Notification>(); if (jsonArray != null) { const int size = jsonArray.size(); for (int i = 0; i < size; i++) { MapBooOLD_Notification* notification = parseNotification(jsonArray.getAsObject(i)); if (notification != null) { result.push_back(notification); } } } return result; } void MapBooOLDBuilder.parseApplicationEventsJSON(const String& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser.instance().parse(json, true); if (jsonBaseObject == null) { ILogger.instance().logError("Can't parse ApplicationJSON from %s", url._path); } else { const JSONArray* jsonArray = jsonBaseObject.asArray(); if (jsonArray != null) { const int size = jsonArray.size(); for (int i = 0; i < size; i++) { const JSONObject* jsonObject = jsonArray.getAsObject(i); parseApplicationJSON(jsonObject, url); } } else { parseApplicationJSON(json, url); } } delete jsonBaseObject; } void MapBooOLDBuilder.parseApplicationJSON(const JSONObject* jsonObject, const URL& url) { java.util.ArrayList<String> errors; if (jsonObject == null) { ILogger.instance().logError("Invalid ApplicationJSON"); } else { const JSONString* jsonError = jsonObject.getAsString("error"); if (jsonError == null) { const int eventId = (int) jsonObject.getAsNumber("eventId", 0); const int timestamp = (int) jsonObject.getAsNumber("timestamp", 0); if (getApplicationEventId() != eventId) { const JSONString* jsonName = jsonObject.getAsString("name"); if (jsonName != null) { setApplicationName(jsonName.value()); } const JSONString* jsonWebsite = jsonObject.getAsString("website"); if (jsonWebsite != null) { setApplicationWebsite(jsonWebsite.value()); } const JSONString* jsonEMail = jsonObject.getAsString("email"); if (jsonEMail != null) { setApplicationEMail(jsonEMail.value()); } const JSONString* jsonAbout = jsonObject.getAsString("about"); if (jsonAbout != null) { setApplicationAbout(jsonAbout.value()); } const JSONObject* jsonScene = jsonObject.getAsObject("scene"); if (jsonScene != null) { parseSceneEventAndUpdateScene(jsonScene); } const JSONArray* jsonAllScenes = jsonObject.getAsArray("scenes"); if (jsonAllScenes != null) { java.util.ArrayList<MapBooOLD_Scene> scenes; const int scenesCount = jsonAllScenes.size(); for (int i = 0; i < scenesCount; i++) { MapBooOLD_Scene* scene = parseScene(jsonAllScenes.getAsObject(i)); if (scene != null) { scenes.push_back(scene); } } setApplicationScenes(scenes); } const JSONObject* jsonScenes = jsonObject.getAsObject("scenes"); if (jsonScenes != null) { const JSONObject* jsonPutScene = jsonScenes.getAsObject("putScene"); if (jsonPutScene != null) { const JSONNumber* jsonPosition = jsonPutScene.getAsNumber("position"); int position = (jsonPosition != null) ? (int) jsonPosition.value() : 0; const JSONObject* jsonNewScene = jsonPutScene.getAsObject("scene"); if (jsonNewScene != null) { MapBooOLD_Scene* scene = parseScene(jsonNewScene); if (scene != null) { addApplicationScene(scene, position); } } } else { const JSONObject* jsonDeleteScene = jsonScenes.getAsObject("deleteScene"); if (jsonDeleteScene != null) { const JSONString* jsonSceneId = jsonDeleteScene.getAsString("sceneId"); if (jsonSceneId != null) { deleteApplicationScene(jsonSceneId.value()); } } } } setApplicationEventId(eventId); setApplicationTimestamp(timestamp); saveApplicationData(); setHasParsedApplication(); } const JSONString* jsonCurrentSceneId = jsonObject.getAsString("currentSceneId"); if (jsonCurrentSceneId != null) { setApplicationCurrentSceneId(jsonCurrentSceneId.value()); } if (_enableNotifications) { const JSONArray* jsonNotifications = jsonObject.getAsArray("notifications"); if (jsonNotifications != null) { addApplicationNotifications(parseNotifications(jsonNotifications)); } const JSONObject* jsonNotification = jsonObject.getAsObject("notification"); if (jsonNotification != null) { addApplicationNotification(parseNotification(jsonNotification)); } } if (_initialParse) { _initialParse = false; if (_applicationCurrentSceneId.compare("-1") == 0) { if (_applicationScenes.size() > 0) { setApplicationCurrentSceneId(_applicationScenes.at(0).getId()); } } } } else { errors.push_back(jsonError.value()); ILogger.instance().logError("Server Error: %s", jsonError.value()); if (_initialParse) { _initialParse = false; setHasParsedApplication(); } } } _mbErrorRenderer.setErrors(errors); } void MapBooOLDBuilder.parseApplicationJSON(const String& json, const URL& url) { const JSONBaseObject* jsonBaseObject = IJSONParser.instance().parse(json, true); if (jsonBaseObject == null) { ILogger.instance().logError("Can't parse ApplicationJSON from %s", url._path); } else { const JSONObject* jsonObject = jsonBaseObject.asObject(); parseApplicationJSON(jsonObject, url); } delete jsonBaseObject; } void MapBooOLDBuilder.parseSceneEventAndUpdateScene(const JSONObject* jsonObject) { if (jsonObject == null) { return; } const JSONString* jsonSceneToBeUpdatedID = jsonObject.getAsString("id"); if (jsonSceneToBeUpdatedID == null) { return; } const String sceneToBeUpdatedID = jsonSceneToBeUpdatedID.value(); const int scenesCount = _applicationScenes.size(); for (int i = 0; i < scenesCount; i++) { const String sceneID = _applicationScenes[i].getId(); if (sceneID.compare(sceneToBeUpdatedID) == 0) { MapBooOLD_Scene* oldScene = _applicationScenes[i]; const String name = jsonObject.getAsString("name", oldScene.getName()); const String description = jsonObject.getAsString("description", oldScene.getDescription()); const JSONBaseObject* jboScreenshot = jsonObject.get("screenshot"); const MapBooOLD_MultiImage* screenshot; if (jboScreenshot != null) { screenshot = parseMultiImage(jboScreenshot.asObject()); } else { const MapBooOLD_MultiImage* oldScreenshot = oldScene.getScreenshot(); screenshot = (oldScreenshot != null) ? oldScreenshot.deepCopy() : null; } const JSONBaseObject* jboBackgroundColor = jsonObject.get("backgroundColor"); const Color backgroundColor = (jboBackgroundColor != null) ? parseColor(jboBackgroundColor.asString()) : oldScene.getBackgroundColor(); const JSONBaseObject* jboCameraPosition = jsonObject.get("cameraPosition"); const MapBooOLD_CameraPosition* cameraPosition; if (jboCameraPosition != null) { cameraPosition = parseCameraPosition(jboCameraPosition.asObject()); } else { const MapBooOLD_CameraPosition* oldCameraPosition = oldScene.getCameraPosition(); cameraPosition = (oldCameraPosition != null) ? new MapBooOLD_CameraPosition(oldCameraPosition.getPosition(), oldCameraPosition.getHeading(), oldCameraPosition.getPitch(), oldCameraPosition.isAnimated()) : null ; } const JSONBaseObject* jboSector = jsonObject.get("sector"); const Sector* sector; if (jboSector != null) { sector = parseSector(jboSector.asObject()); } else { const Sector* oldSector = oldScene.getSector(); sector = (oldSector != null) ? new Sector(oldSector._lower, oldSector._upper) : null; } const JSONBaseObject* jboBaseLayer = jsonObject.get("baseLayer"); Layer* baseLayer = (jboBaseLayer != null) ? parseLayer(jboBaseLayer.asObject()) : oldScene.getBaseLayer().copy(); const JSONBaseObject* jboOverlayLayer = jsonObject.get("overlayLayer"); Layer* oldOverlayLayer = (oldScene.getOverlayLayer() != null) ? oldScene.getOverlayLayer().copy() : null; Layer* overlayLayer = (jboOverlayLayer != null) ? parseLayer(jboOverlayLayer.asObject()) : oldOverlayLayer; const boolean hasWarnings = jsonObject.getAsBoolean("hasWarnings", false); const boolean queryable = jsonObject.getAsBoolean("queryable", oldScene.isQueryable()); const boolean cameraPositionChaged = (jboCameraPosition != null); MapBooOLD_Scene* newScene = new MapBooOLD_Scene(sceneToBeUpdatedID, name, description, screenshot, backgroundColor, cameraPosition, sector, baseLayer, overlayLayer, queryable, hasWarnings); _applicationScenes[i] = newScene; if (sceneID.compare(_applicationCurrentSceneId) == 0) { updateVisibleScene(cameraPositionChaged); } if (_applicationListener != null) { _applicationListener.onSceneChanged(_context, newScene); } fireOnScenesChanged(); delete oldScene; break; } } } void MapBooOLDBuilder.addApplicationNotifications(const java.util.ArrayList<MapBooOLD_Notification>* notifications) { if (notifications == null) { return; } const int size = notifications.size(); for (int i = 0; i < size; i++) { MapBooOLD_Notification* notification = notifications.at(i); if (notification != null) { addApplicationNotification(notification); } } delete notifications; } void MapBooOLDBuilder.addApplicationNotification(MapBooOLD_Notification* notification) { if (_marksRenderer != null) { const String message = notification.getMessage(); const boolean hasMessage = (message.size() > 0); const URL* iconURL = notification.getIconURL(); const Geodetic2D position = notification.getPosition(); boolean newMark = false; if (hasMessage) { if (iconURL == null) { _marksRenderer.addMark(new Mark(message, Geodetic3D(position, 0), ABSOLUTE, 0)); } else { _marksRenderer.addMark(new Mark(message, *iconURL, Geodetic3D(position, 0), ABSOLUTE, 0)); } newMark = true; } else { if (iconURL != null) { _marksRenderer.addMark(new Mark(*iconURL, Geodetic3D(position, 0), ABSOLUTE, 0)); newMark = true; } } if (newMark) { const MapBooOLD_CameraPosition* cameraPosition = notification.getCameraPosition(); if (cameraPosition != null) { setCameraPosition(cameraPosition, true); } } } delete notification; } void MapBooOLDBuilder.setApplicationCurrentSceneId(const String& currentSceneId) { if (_applicationCurrentSceneId.compare(currentSceneId) != 0) { const int scenesCount = _applicationScenes.size(); for (int i = 0; i < scenesCount; i++) { const String sceneId = _applicationScenes[i].getId(); if (sceneId.compare(currentSceneId) == 0) { _applicationCurrentSceneId = currentSceneId; changedCurrentScene(); break; } } } } LayerSet* MapBooOLD_Scene.createLayerSet() const { LayerSet* layerSet = new LayerSet(); if (_baseLayer != null) { layerSet.addLayer(_baseLayer.copy()); } if (_overlayLayer != null) { layerSet.addLayer(_overlayLayer.copy()); } return layerSet; } void MapBooOLDBuilder.recreateLayerSet() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); if (scene == null) { _layerSet.removeAllLayers(true); } else { LayerSet* newLayerSet = scene.createLayerSet(); if (!newLayerSet.isEquals(_layerSet)) { _layerSet.removeAllLayers(true); _layerSet.takeLayersFrom(newLayerSet); } delete newLayerSet; } } const URL MapBooOLDBuilder.createApplicationTubeURL() const { const String tubesPath = _tubesURL._path; String view; switch (_viewType) { case VIEW_PRESENTATION: view = "presentation"; break; case VIEW_EDITION_PREVIEW: view = "edition-preview"; break; default: view = "runtime"; } return URL(tubesPath + "/application/" + _applicationId + "/" + view, false); } class MapBooOLDBuilder_TubeWatchdogPeriodicalTask : public GTask { private: MapBooOLDBuilder* _builder; boolean _firstRun; public: MapBooOLDBuilder_TubeWatchdogPeriodicalTask(MapBooOLDBuilder* builder) : _builder(builder), _firstRun(true) { } void run(const G3MContext* context) { if (_firstRun) { _firstRun = false; } else { if (!_builder.isApplicationTubeOpen()) { _builder.pollApplicationDataFromServer(context); _builder.openApplicationTube(context); } } } }; java.util.ArrayList<PeriodicalTask>* MapBooOLDBuilder.createPeriodicalTasks() { java.util.ArrayList<PeriodicalTask>* periodicalTasks = new java.util.ArrayList<PeriodicalTask>(); periodicalTasks.push_back(new PeriodicalTask(TimeInterval.fromSeconds(5), new MapBooOLDBuilder_TubeWatchdogPeriodicalTask(this))); return periodicalTasks; } IStorage* MapBooOLDBuilder.getStorage() { if (_storage == null) { _storage = createStorage(); } return _storage; } class MapBooOLDBuilder_ApplicationTubeListener : public IWebSocketListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeListener(MapBooOLDBuilder* builder) : _builder(builder) { } ~MapBooOLDBuilder_ApplicationTubeListener() { } void onOpen(IWebSocket* ws) { ILogger.instance().logInfo("Tube '%s' opened!", ws.getURL()._path); _builder.setApplicationTubeOpened(true); } void onError(IWebSocket* ws, const String& error) { ILogger.instance().logError("Error '%s' on Tube '%s'", error, ws.getURL()._path); _builder.setApplicationTubeOpened(false); } void onMessage(IWebSocket* ws, const String& message) { _builder.parseApplicationJSON(message, ws.getURL()); } void onClose(IWebSocket* ws) { ILogger.instance().logError("Tube '%s' closed!", ws.getURL()._path); _builder.setApplicationTubeOpened(false); } }; class MapBooOLDBuilder_ApplicationTubeConnector : public GInitializationTask { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_ApplicationTubeConnector(MapBooOLDBuilder* builder) : _builder(builder) { } void run(const G3MContext* context) { _builder.setContext(context); _builder.openApplicationTube(context); } boolean isDone(const G3MContext* context) { return _builder.hasParsedApplication(); } }; void MapBooOLDBuilder.setContext(const G3MContext* context) { _context = context; } MapBooOLDBuilder.~MapBooOLDBuilder() { } class MapBooOLDBuilder_RestJSON : public IBufferDownloadListener { private: MapBooOLDBuilder* _builder; public: MapBooOLDBuilder_RestJSON(MapBooOLDBuilder* builder) : _builder(builder) { } void onDownload(const URL& url, IByteBuffer* buffer, boolean expired) { _builder.parseApplicationEventsJSON(buffer.getAsString(), url); delete buffer; } void onError(const URL& url) { ILogger.instance().logError("Can't download %s", url._path); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, boolean expired) { } }; const URL MapBooOLDBuilder.createApplicationPollURL() const { IStringBuilder* isb = IStringBuilder.newStringBuilder(); isb.addString(_serverURL._path); isb.addString("/poll/"); isb.addString(_applicationId); isb.addString("?view="); isb.addString(getViewAsString()); isb.addString("&eventId="); isb.addInt(_applicationEventId); const String path = isb.getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder.openApplicationTube(const G3MContext* context) { const IFactory* factory = context.getFactory(); _webSocket = factory.createWebSocket(createApplicationTubeURL(), new MapBooOLDBuilder_ApplicationTubeListener(this), true, true); } const String MapBooOLDBuilder.getApplicationCurrentSceneId() { return _applicationCurrentSceneId; } const MapBooOLD_Scene* MapBooOLDBuilder.getApplicationCurrentScene() { const String currentSceneId = getApplicationCurrentSceneId(); const int scenesCount = _applicationScenes.size(); for (int i = 0; i < scenesCount; i++) { const String sceneId = _applicationScenes[i].getId(); if (sceneId.compare(currentSceneId) == 0) { return _applicationScenes[i]; } } return null; } Color MapBooOLDBuilder.getCurrentBackgroundColor() { const MapBooOLD_Scene* scene = getApplicationCurrentScene(); return (scene == null) ? Color.black() : scene.getBackgroundColor(); } MarksRenderer* MapBooOLDBuilder.getMarksRenderer() { if (_marksRenderer == null) { _marksRenderer = new MarksRenderer(false); } return _marksRenderer; } G3MWidget* MapBooOLDBuilder.create() { if (_g3mWidget != null) { ILogger.instance().logError("The G3MWidget was already created, can't be created more than once"); return null; } CompositeRenderer* mainRenderer = new CompositeRenderer(); _mbErrorRenderer = new MapBooOLD_ErrorRenderer(); mainRenderer.addRenderer(_mbErrorRenderer); const Planet* planet = createPlanet(); PlanetRenderer* planetRenderer = createPlanetRenderer(); mainRenderer.addRenderer(planetRenderer); mainRenderer.addRenderer(getMarksRenderer()); java.util.ArrayList<ICameraConstrainer>* cameraConstraints = createCameraConstraints(planet, planetRenderer); GInitializationTask* initializationTask = new MapBooOLDBuilder_ApplicationTubeConnector(this); java.util.ArrayList<PeriodicalTask>* periodicalTasks = createPeriodicalTasks(); ICameraActivityListener* cameraActivityListener = null; InitialCameraPositionProvider* icpp = new SimpleInitialCameraPositionProvider(); MapBooOLD_HUDRenderer* hudRenderer = new MapBooOLD_HUDRenderer(); InfoDisplay* infoDisplay = new MapBooOLD_HUDRendererInfoDisplay(hudRenderer); infoDisplay.showDisplay(); _g3mWidget = G3MWidget.create(getGL(), getStorage(), getDownloader(), getThreadUtils(), cameraActivityListener, planet, *cameraConstraints, createCameraRenderer(), mainRenderer, createBusyRenderer(), createErrorRenderer(), hudRenderer, Color.black(), false, false, initializationTask, true, *periodicalTasks, getGPUProgramManager(), createSceneLighting(), icpp, infoDisplay, MONO); delete cameraConstraints; delete periodicalTasks; return _g3mWidget; } int MapBooOLDBuilder.getApplicationEventId() const { return _applicationEventId; } void MapBooOLDBuilder.setApplicationEventId(const int eventId) { _applicationEventId = eventId; } int MapBooOLDBuilder.getApplicationTimestamp() const { return _applicationTimestamp; } const String MapBooOLDBuilder.getApplicationId() { return _applicationId; } void MapBooOLDBuilder.saveApplicationData() const { } void MapBooOLDBuilder.setHasParsedApplication() { _hasParsedApplication = true; } boolean MapBooOLDBuilder.hasParsedApplication() const { return _hasParsedApplication; } void MapBooOLDBuilder.setApplicationTimestamp(const int timestamp) { _applicationTimestamp = timestamp; } void MapBooOLDBuilder.setApplicationName(const String& name) { if (_applicationName.compare(name) != 0) { _applicationName = name; if (_applicationListener != null) { _applicationListener.onNameChanged(_context, _applicationName); } } } void MapBooOLDBuilder.setApplicationWebsite(const String& website) { if (_applicationWebsite.compare(website) != 0) { _applicationWebsite = website; if (_applicationListener != null) { _applicationListener.onWebsiteChanged(_context, _applicationWebsite); } } } void MapBooOLDBuilder.setApplicationEMail(const String& eMail) { if (_applicationEMail.compare(eMail) != 0) { _applicationEMail = eMail; if (_applicationListener != null) { _applicationListener.onEMailChanged(_context, _applicationEMail); } } } void MapBooOLDBuilder.setApplicationAbout(const String& about) { if (_applicationAbout.compare(about) != 0) { _applicationAbout = about; if (_applicationListener != null) { _applicationListener.onAboutChanged(_context, _applicationAbout); } } } class MapBooOLDBuilder_ChangeSceneTask : public GTask { private: MapBooOLDBuilder* _builder; const String _sceneId; public: MapBooOLDBuilder_ChangeSceneTask(MapBooOLDBuilder* builder, const String& sceneId) : _builder(builder), _sceneId(sceneId) { } void run(const G3MContext* context) { _builder.rawChangeScene(_sceneId); } }; void MapBooOLDBuilder.rawChangeScene(const String& sceneId) { _applicationCurrentSceneId = sceneId; changedCurrentScene(); } void MapBooOLDBuilder.changeScene(const String& sceneId) { const String currentSceneId = getApplicationCurrentSceneId(); if (currentSceneId.compare(sceneId) != 0) { const int scenesCount = _applicationScenes.size(); for (int i = 0; i < scenesCount; i++) { const String iSceneId = _applicationScenes[i].getId(); if (sceneId.compare(iSceneId) == 0) { getThreadUtils().invokeInRendererThread(new MapBooOLDBuilder_ChangeSceneTask(this, sceneId), true); break; } } } } void MapBooOLDBuilder.changeScene(const MapBooOLD_Scene* scene) { const int size = _applicationScenes.size(); for (int i = 0; i < size; i++) { if (_applicationScenes[i] == scene) { changeScene(scene.getId()); break; } } } class MapBooOLDBuilder_DummyListener : public IBufferDownloadListener { public: MapBooOLDBuilder_DummyListener() { } void onDownload(const URL& url, IByteBuffer* buffer, boolean expired) { delete buffer; } void onError(const URL& url) { ILogger.instance().logError("Can't download %s", url._path); } void onCancel(const URL& url) { } void onCanceledDownload(const URL& url, IByteBuffer* buffer, boolean expired) { } }; void MapBooOLDBuilder.changedCurrentScene() { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != null) { _g3mWidget.setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget.resetPeriodicalTasksTimeouts(); if (currentScene != null) { const Sector* sector = currentScene.getSector(); if (sector == null) { _g3mWidget.setRenderedSector(Sector.fullSphere()); } else { _g3mWidget.setRenderedSector(*sector); } setCameraPosition(currentScene.getCameraPosition()); } } if (_applicationListener != null) { _applicationListener.onCurrentSceneChanged(_context, getApplicationCurrentSceneId(), currentScene); } if (_viewType == VIEW_EDITION_PREVIEW) { if (_applicationCurrentSceneId.compare(_lastApplicationCurrentSceneId) != 0) { if (_lastApplicationCurrentSceneId.compare("-1") != 0) { if (_webSocket != null && _isApplicationTubeOpen) { _webSocket.send(getApplicationCurrentSceneCommand()); } else if (_token.length() > 0) { _g3mWidget.getG3MContext().getDownloader().requestBuffer(createApplicationCurrentSceneURL(), DownloadPriority.HIGHEST, TimeInterval.zero(), false, new MapBooOLDBuilder_DummyListener(), false); } else { ILogger.instance().logError("VIEW_PRESENTATION: can't fire the event of changed scene"); } } _lastApplicationCurrentSceneId = _applicationCurrentSceneId; } } } const String MapBooOLDBuilder.getApplicationCurrentSceneCommand() const { IStringBuilder* isb = IStringBuilder.newStringBuilder(); isb.addString("currentSceneId="); isb.addString(_applicationCurrentSceneId); const String s = isb.getString(); delete isb; return s; } const URL MapBooOLDBuilder.createApplicationCurrentSceneURL() const { IStringBuilder* isb = IStringBuilder.newStringBuilder(); isb.addString(_serverURL._path); isb.addString("/REST/1/applications/"); isb.addString(_applicationId); isb.addString("/_POST_?"); isb.addString("currentSceneId="); isb.addString(_applicationCurrentSceneId); isb.addString("&token="); isb.addString(_token); const String path = isb.getString(); delete isb; return URL(path, false); } void MapBooOLDBuilder.updateVisibleScene(const boolean cameraPositionChanged) { recreateLayerSet(); const MapBooOLD_Scene* currentScene = getApplicationCurrentScene(); if (_g3mWidget != null) { _g3mWidget.setBackgroundColor(getCurrentBackgroundColor()); _g3mWidget.resetPeriodicalTasksTimeouts(); if (currentScene != null) { const Sector* sector = currentScene.getSector(); if (sector == null) { _g3mWidget.setRenderedSector(Sector.fullSphere()); } else { _g3mWidget.setRenderedSector(*sector); } if (cameraPositionChanged) { setCameraPosition(currentScene.getCameraPosition()); } } } } void MapBooOLDBuilder.setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition, const boolean animated) { if (cameraPosition != null) { if (animated) { _g3mWidget.setAnimatedCameraPosition(TimeInterval.fromSeconds(3), cameraPosition.getPosition(), cameraPosition.getHeading(), cameraPosition.getPitch()); } else { _g3mWidget.setCameraPosition(cameraPosition.getPosition()); _g3mWidget.setCameraHeading(cameraPosition.getHeading()); _g3mWidget.setCameraPitch(cameraPosition.getPitch()); } } } void MapBooOLDBuilder.setCameraPosition(const MapBooOLD_CameraPosition* cameraPosition) { if (cameraPosition != null) { const boolean animated = cameraPosition.isAnimated(); setCameraPosition(cameraPosition, animated); } } void MapBooOLDBuilder.fireOnScenesChanged() { if (_applicationListener != null) { } } void MapBooOLDBuilder.addApplicationScene(MapBooOLD_Scene* scene, const int position) { fireOnScenesChanged(); } void MapBooOLDBuilder.deleteApplicationScene(const String &sceneId) { const int scenesCount = _applicationScenes.size(); int sceneIndex = -1; for (int i = 0; i < scenesCount; i++) { const String iSceneId = _applicationScenes[i].getId(); if (iSceneId.compare(sceneId) == 0) { sceneIndex = i; break; } } if (sceneIndex != -1) { MapBooOLD_Scene* scene = _applicationScenes[sceneIndex]; delete scene; if (_viewType == VIEW_RUNTIME) { if (_applicationCurrentSceneId.compare(sceneId) == 0) { setApplicationCurrentSceneId(_applicationScenes[0].getId()); } } fireOnScenesChanged(); } } void MapBooOLDBuilder.setApplicationScenes(const java.util.ArrayList<MapBooOLD_Scene>& applicationScenes) { const int currentScenesCount = _applicationScenes.size(); for (int i = 0; i < currentScenesCount; i++) { MapBooOLD_Scene* scene = _applicationScenes[i]; delete scene; } _applicationScenes.clear(); fireOnScenesChanged(); } SceneLighting* MapBooOLDBuilder.createSceneLighting() { return new CameraFocusSceneLighting(Color.fromRGBA((float)0.3, (float)0.3, (float)0.3, (float)1.0), Color.yellow()); } void MapBooOLDBuilder.setApplicationTubeOpened(boolean open) { if (_isApplicationTubeOpen != open) { _isApplicationTubeOpen = open; if (!_isApplicationTubeOpen) { _webSocket = null; } if (_isApplicationTubeOpen) { if (_applicationListener != null) { _applicationListener.onWebSocketOpen(_context); } } else { if (_applicationListener != null) { _applicationListener.onWebSocketClose(_context); } } } } const MapBooOLD_Notification* MapBooOLDBuilder.createNotification(const Geodetic2D& position, const Camera* camera, const String& message, const URL* iconURL) const { MapBooOLD_CameraPosition* cameraPosition = new MapBooOLD_CameraPosition(camera.getGeodeticPosition(), camera.getHeading(), camera.getPitch(), true); return new MapBooOLD_Notification(position, cameraPosition, message, iconURL); } void MapBooOLDBuilder.pollApplicationDataFromServer(const G3MContext *context) { IDownloader* downloader = context.getDownloader(); downloader.requestBuffer(createApplicationPollURL(), DownloadPriority.HIGHEST, TimeInterval.zero(), false, new MapBooOLDBuilder_RestJSON(this), true); } const String MapBooOLDBuilder.getViewAsString() const { switch (_viewType) { case VIEW_EDITION_PREVIEW: return "edition-preview"; case VIEW_PRESENTATION: return "presentation"; case VIEW_RUNTIME: default: return "runtime"; } } const URL MapBooOLDBuilder.createGetFeatureInfoRestURL(const Tile* tile, const Vector2I& tileDimension, const Vector2I& pixelPosition, const Geodetic3D& position) { IStringBuilder* isb = IStringBuilder.newStringBuilder(); isb.addString(_serverURL._path); isb.addString("/Public/applications/"); isb.addString(_applicationId); isb.addString("/scenes/"); const MapBooOLD_Scene* scene = getApplicationCurrentScene(); isb.addString(scene.getId()); isb.addString("/getinfo?"); isb.addString("tileX="); isb.addInt(tile._column); isb.addString("&tileY="); isb.addInt(tile._row); isb.addString("&tileLevel="); isb.addInt(tile._level); isb.addString("&upperLat="); isb.addDouble(tile._sector._upper._latitude._degrees); isb.addString("&lowerLat="); isb.addDouble(tile._sector._lower._latitude._degrees); isb.addString("&upperLon="); isb.addDouble(tile._sector._upper._longitude._degrees); isb.addString("&lowerLon="); isb.addDouble(tile._sector._lower._longitude._degrees); isb.addString("&tileBBox="); isb.addString("TODO"); isb.addString("&tileWidth="); isb.addInt(tileDimension._x); isb.addString("&tileHeight="); isb.addInt(tileDimension._y); isb.addString("&pixelX="); isb.addInt(pixelPosition._x); isb.addString("&pixelY="); isb.addInt(pixelPosition._y); isb.addString("&lat="); isb.addDouble(position._latitude._degrees); isb.addString("&lon="); isb.addDouble(position._longitude._degrees); const String path = isb.getString(); delete isb; return URL(path, false); } const void MapBooOLDBuilder.requestGetFeatureInfo(const Tile* tile, const Vector2I& size, const Vector2I& pixel, const Geodetic3D& position) { _g3mWidget.getG3MContext().getDownloader().requestBuffer(createGetFeatureInfoRestURL(tile, size, pixel, position), DownloadPriority.HIGHER, TimeInterval.zero(), false, _featureInfoDownloadListener, false); } void HUDInfoRenderer_ImageFactory.drawOn(ICanvas* canvas, int width, int height) { java.util.ArrayList<String> strings; const int size = _info.size(); for (int i = 0; i < size; i++) { strings.push_back(_info.at(i).getText()); } ICanvasUtils.drawStringsOn(strings, canvas, width, height, Left, Bottom, Left, Color.white(), 11, 2, Color.transparent(), Color.black(), 5); } boolean HUDInfoRenderer_ImageFactory.isEquals(const java.util.ArrayList<Info>& v1, const java.util.ArrayList<Info>& v2) const { const int size1 = v1.size(); const int size2 = v2.size(); if (size1 != size2) { return false; } for (int i = 0; i < size1; i++) { const Info* str1 = v1[i]; const Info* str2 = v2[i]; if (str1 != str2) { return false; } } return true; } boolean HUDInfoRenderer_ImageFactory.setInfo(const java.util.ArrayList<Info>& info) { if (isEquals(_info, info)) { return false; } _info.clear(); return true; } MapBooOLD_HUDRenderer.MapBooOLD_HUDRenderer() { _hudImageRenderer = new HUDImageRenderer(new HUDInfoRenderer_ImageFactory()); } MapBooOLD_HUDRenderer.~MapBooOLD_HUDRenderer() { delete _hudImageRenderer; } void MapBooOLD_HUDRenderer.updateInfo(const java.util.ArrayList<Info>& info) { HUDInfoRenderer_ImageFactory* factory = (HUDInfoRenderer_ImageFactory*)(_hudImageRenderer.getImageFactory()); if (factory.setInfo(info)) { _hudImageRenderer.recreateImage(); } } void MapBooOLD_HUDRenderer.initialize(const G3MContext* context) { _hudImageRenderer.initialize(context); } void MapBooOLD_HUDRenderer.render(const G3MRenderContext* rc, GLState* glState) { _hudImageRenderer.render(rc, glState); } void MapBooOLD_HUDRenderer.onResizeViewportEvent(const G3MEventContext* ec, int width, int height) { _hudImageRenderer.onResizeViewportEvent(ec, width, height); } void MapBooOLD_HUDRenderer.start(const G3MRenderContext* rc) { _hudImageRenderer.start(rc); } void MapBooOLD_HUDRenderer.stop(const G3MRenderContext* rc) { _hudImageRenderer.stop(rc); } void MapBooOLD_HUDRenderer.onResume(const G3MContext* context) { _hudImageRenderer.onResume(context); } void MapBooOLD_HUDRenderer.onPause(const G3MContext* context) { _hudImageRenderer.onPause(context); } void MapBooOLD_HUDRenderer.onDestroy(const G3MContext* context) { _hudImageRenderer.onDestroy(context); } void MapBooOLD_ErrorRenderer.setErrors(const java.util.ArrayList<String>& errors) { _errors = errors; } RenderState MapBooOLD_ErrorRenderer.getRenderState(const G3MRenderContext* rc) { if (_errors.size() > 0) { return RenderState.error(_errors); } return RenderState.ready(); } void MapBooOLDBuilder.setTileLODTester(TileLODTester* tlt) { _tileLODTester = tlt; } TileLODTester* MapBooOLDBuilder.createDefaultTileLODTester() const { return null; } TileLODTester* MapBooOLDBuilder.getTileLODTester() { if (_tileLODTester == null) { _tileLODTester = createDefaultTileLODTester(); } return _tileLODTester; } TileVisibilityTester* MapBooOLDBuilder.createDefaultTileVisibilityTester() const { return null; } TileVisibilityTester* MapBooOLDBuilder.getTileVisibilityTester() { if (_tileVisibilityTester == null) { _tileVisibilityTester = createDefaultTileVisibilityTester(); } return _tileVisibilityTester; }
